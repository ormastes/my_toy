diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
deleted file mode 100644
index 2da05ef870b9..000000000000
--- a/llvm/CMakeLists.txt
+++ /dev/null
@@ -1,1263 +0,0 @@
-# See docs/CMake.html for instructions about how to build LLVM with CMake.
-
-cmake_minimum_required(VERSION 3.13.4)
-
-# CMP0116: Ninja generators transform `DEPFILE`s from `add_custom_command()`
-# New in CMake 3.20. https://cmake.org/cmake/help/latest/policy/CMP0116.html
-if(POLICY CMP0116)
-  cmake_policy(SET CMP0116 OLD)
-endif()
-
-set(CMAKE_BUILD_WITH_INSTALL_NAME_DIR ON)
-
-if(NOT DEFINED LLVM_VERSION_MAJOR)
-  set(LLVM_VERSION_MAJOR 14)
-endif()
-if(NOT DEFINED LLVM_VERSION_MINOR)
-  set(LLVM_VERSION_MINOR 0)
-endif()
-if(NOT DEFINED LLVM_VERSION_PATCH)
-  set(LLVM_VERSION_PATCH 6)
-endif()
-if(NOT DEFINED LLVM_VERSION_SUFFIX)
-  set(LLVM_VERSION_SUFFIX)
-endif()
-
-if (NOT PACKAGE_VERSION)
-  set(PACKAGE_VERSION
-    "${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}${LLVM_VERSION_SUFFIX}")
-endif()
-
-if(NOT DEFINED LLVM_SHLIB_SYMBOL_VERSION)
-  # "Symbol version prefix for libLLVM.so"
-  set(LLVM_SHLIB_SYMBOL_VERSION "LLVM_${LLVM_VERSION_MAJOR}")
-endif()
-
-if ((CMAKE_GENERATOR MATCHES "Visual Studio") AND (MSVC_TOOLSET_VERSION LESS 142) AND (CMAKE_GENERATOR_TOOLSET STREQUAL ""))
-  message(WARNING "Visual Studio generators use the x86 host compiler by "
-                  "default, even for 64-bit targets. This can result in linker "
-                  "instability and out of memory errors. To use the 64-bit "
-                  "host compiler, pass -Thost=x64 on the CMake command line.")
-endif()
-
-if (CMAKE_GENERATOR STREQUAL "Xcode" AND NOT CMAKE_OSX_ARCHITECTURES)
-  # Some CMake features like object libraries get confused if you don't
-  # explicitly specify an architecture setting with the Xcode generator.
-  set(CMAKE_OSX_ARCHITECTURES "x86_64")
-endif()
-
-project(LLVM
-  VERSION ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}
-  LANGUAGES C CXX ASM)
-
-# Must go after project(..)
-include(GNUInstallDirs)
-
-set(CMAKE_CXX_STANDARD 14 CACHE STRING "C++ standard to conform to")
-set(CMAKE_CXX_STANDARD_REQUIRED YES)
-if (CYGWIN)
-  # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in
-  # c++xx mode.
-  set(CMAKE_CXX_EXTENSIONS YES)
-else()
-  set(CMAKE_CXX_EXTENSIONS NO)
-endif()
-
-if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-  message(STATUS "No build type selected, default to Debug")
-  set(CMAKE_BUILD_TYPE "Debug" CACHE STRING "Build type (default Debug)" FORCE)
-endif()
-
-# Side-by-side subprojects layout: automatically set the
-# LLVM_EXTERNAL_${project}_SOURCE_DIR using LLVM_ALL_PROJECTS
-# This allows an easy way of setting up a build directory for llvm and another
-# one for llvm+clang+... using the same sources.
-set(LLVM_ALL_PROJECTS "bolt;clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;polly;pstl")
-# The flang project is not yet part of "all" projects (see C++ requirements)
-set(LLVM_EXTRA_PROJECTS "flang")
-# List of all known projects in the mono repo
-set(LLVM_KNOWN_PROJECTS "${LLVM_ALL_PROJECTS};${LLVM_EXTRA_PROJECTS}")
-set(LLVM_ENABLE_PROJECTS "" CACHE STRING
-    "Semicolon-separated list of projects to build (${LLVM_KNOWN_PROJECTS}), or \"all\".")
-foreach(proj ${LLVM_ENABLE_PROJECTS})
-  if (NOT proj STREQUAL "all" AND NOT proj STREQUAL "llvm" AND NOT "${proj}" IN_LIST LLVM_KNOWN_PROJECTS)
-     MESSAGE(FATAL_ERROR "${proj} isn't a known project: ${LLVM_KNOWN_PROJECTS}")
-  endif()
-endforeach()
-foreach(proj "libcxx" "libcxxabi" "libunwind")
-  if (${proj} IN_LIST LLVM_ENABLE_PROJECTS)
-    message(WARNING "Using LLVM_ENABLE_PROJECTS=${proj} is deprecated now, please use -DLLVM_ENABLE_RUNTIMES=${proj} or "
-                    "see the instructions at https://libcxx.llvm.org/BuildingLibcxx.html for building the runtimes.")
-  endif()
-endforeach()
-
-if( LLVM_ENABLE_PROJECTS STREQUAL "all" )
-  set( LLVM_ENABLE_PROJECTS ${LLVM_ALL_PROJECTS})
-endif()
-
-if ("flang" IN_LIST LLVM_ENABLE_PROJECTS)
-  if (NOT "mlir" IN_LIST LLVM_ENABLE_PROJECTS)
-    message(STATUS "Enabling MLIR as a dependency to flang")
-    list(APPEND LLVM_ENABLE_PROJECTS "mlir")
-  endif()
-
-  if (NOT "clang" IN_LIST LLVM_ENABLE_PROJECTS)
-    message(FATAL_ERROR "Clang is not enabled, but is required for the Flang driver")
-  endif()
-endif()
-
-# LLVM_ENABLE_PROJECTS_USED is `ON` if the user has ever used the
-# `LLVM_ENABLE_PROJECTS` CMake cache variable.  This exists for
-# several reasons:
-#
-# * As an indicator that the `LLVM_ENABLE_PROJECTS` list is now the single
-# source of truth for which projects to build. This means we will ignore user
-# supplied `LLVM_TOOL_<project>_BUILD` CMake cache variables and overwrite
-# them.
-#
-# * The case where the user previously had `LLVM_ENABLE_PROJECTS` set to a
-# non-empty list but now the user wishes to disable building all other projects
-# by setting `LLVM_ENABLE_PROJECTS` to an empty string. In that case we still
-# need to set the `LLVM_TOOL_${upper_proj}_BUILD` variables so that we disable
-# building all the projects that were previously enabled.
-set(LLVM_ENABLE_PROJECTS_USED OFF CACHE BOOL "")
-mark_as_advanced(LLVM_ENABLE_PROJECTS_USED)
-
-if (LLVM_ENABLE_PROJECTS_USED OR NOT LLVM_ENABLE_PROJECTS STREQUAL "")
-  set(LLVM_ENABLE_PROJECTS_USED ON CACHE BOOL "" FORCE)
-  foreach(proj ${LLVM_KNOWN_PROJECTS} ${LLVM_EXTERNAL_PROJECTS})
-    string(TOUPPER "${proj}" upper_proj)
-    string(REGEX REPLACE "-" "_" upper_proj ${upper_proj})
-    if ("${proj}" IN_LIST LLVM_ENABLE_PROJECTS)
-      message(STATUS "${proj} project is enabled")
-      set(SHOULD_ENABLE_PROJECT TRUE)
-      set(PROJ_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}")
-      if(NOT EXISTS "${PROJ_DIR}" OR NOT IS_DIRECTORY "${PROJ_DIR}")
-        message(FATAL_ERROR "LLVM_ENABLE_PROJECTS requests ${proj} but directory not found: ${PROJ_DIR}")
-      endif()
-      if( LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR STREQUAL "" )
-        set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}" CACHE PATH "" FORCE)
-      else()
-        set(LLVM_EXTERNAL_${upper_proj}_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../${proj}" CACHE PATH "")
-      endif()
-    elseif ("${proj}" IN_LIST LLVM_EXTERNAL_PROJECTS)
-      message(STATUS "${proj} project is enabled")
-      set(SHOULD_ENABLE_PROJECT TRUE)
-    else()
-      message(STATUS "${proj} project is disabled")
-      set(SHOULD_ENABLE_PROJECT FALSE)
-    endif()
-    # Force `LLVM_TOOL_${upper_proj}_BUILD` variables to have values that
-    # corresponds with `LLVM_ENABLE_PROJECTS`. This prevents the user setting
-    # `LLVM_TOOL_${upper_proj}_BUILD` variables externally. At some point
-    # we should deprecate allowing users to set these variables by turning them
-    # into normal CMake variables rather than cache variables.
-    set(LLVM_TOOL_${upper_proj}_BUILD
-      ${SHOULD_ENABLE_PROJECT}
-      CACHE
-      BOOL "Whether to build ${upper_proj} as part of LLVM" FORCE
-    )
-  endforeach()
-endif()
-unset(SHOULD_ENABLE_PROJECT)
-
-# Build llvm with ccache if the package is present
-set(LLVM_CCACHE_BUILD OFF CACHE BOOL "Set to ON for a ccache enabled build")
-if(LLVM_CCACHE_BUILD)
-  find_program(CCACHE_PROGRAM ccache)
-  if(CCACHE_PROGRAM)
-      set(LLVM_CCACHE_MAXSIZE "" CACHE STRING "Size of ccache")
-      set(LLVM_CCACHE_DIR "" CACHE STRING "Directory to keep ccached data")
-      set(LLVM_CCACHE_PARAMS "CCACHE_CPP2=yes CCACHE_HASHDIR=yes"
-          CACHE STRING "Parameters to pass through to ccache")
-
-      set(CCACHE_PROGRAM "${LLVM_CCACHE_PARAMS} ${CCACHE_PROGRAM}")
-      if (LLVM_CCACHE_MAXSIZE)
-        set(CCACHE_PROGRAM "CCACHE_MAXSIZE=${LLVM_CCACHE_MAXSIZE} ${CCACHE_PROGRAM}")
-      endif()
-      if (LLVM_CCACHE_DIR)
-        set(CCACHE_PROGRAM "CCACHE_DIR=${LLVM_CCACHE_DIR} ${CCACHE_PROGRAM}")
-      endif()
-      set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})
-  else()
-    message(FATAL_ERROR "Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF")
-  endif()
-endif()
-
-set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS "" CACHE STRING
-  "Optional arguments for the native tool used in CMake --build invocations for external projects.")
-mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS)
-
-option(LLVM_DEPENDENCY_DEBUGGING "Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)" OFF)
-
-# Some features of the LLVM build may be disallowed when dependency debugging is
-# enabled. In particular you cannot use ccache because we want to force compile
-# operations to always happen.
-if(LLVM_DEPENDENCY_DEBUGGING)
-  if(NOT CMAKE_HOST_APPLE)
-    message(FATAL_ERROR "Dependency debugging is only currently supported on Darwin hosts.")
-  endif()
-  if(LLVM_CCACHE_BUILD)
-    message(FATAL_ERROR "Cannot enable dependency debugging while using ccache.")
-  endif()
-endif()
-
-option(LLVM_ENABLE_DAGISEL_COV "Debug: Prints tablegen patterns that were used for selecting" OFF)
-option(LLVM_ENABLE_GISEL_COV "Enable collection of GlobalISel rule coverage" OFF)
-if(LLVM_ENABLE_GISEL_COV)
-  set(LLVM_GISEL_COV_PREFIX "${CMAKE_BINARY_DIR}/gisel-coverage-" CACHE STRING "Provide a filename prefix to collect the GlobalISel rule coverage")
-endif()
-
-set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake)
-
-# Add path for custom modules
-list(INSERT CMAKE_MODULE_PATH 0
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
-  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
-  "${LLVM_COMMON_CMAKE_UTILS}/Modules"
-  )
-
-# Generate a CompilationDatabase (compile_commands.json file) for our build,
-# for use by clang_complete, YouCompleteMe, etc.
-set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
-
-option(LLVM_INSTALL_BINUTILS_SYMLINKS
-  "Install symlinks from the binutils tool names to the corresponding LLVM tools." OFF)
-
-option(LLVM_INSTALL_CCTOOLS_SYMLINKS
-  "Install symlinks from the cctools tool names to the corresponding LLVM tools." OFF)
-
-option(LLVM_INSTALL_UTILS "Include utility binaries in the 'install' target." OFF)
-
-option(LLVM_INSTALL_TOOLCHAIN_ONLY "Only include toolchain files in the 'install' target." OFF)
-
-# Unfortunatly Clang is too eager to search directories for module maps, which can cause the
-# installed version of the maps to be found when building LLVM from source. Therefore we turn off
-# the installation by default. See llvm.org/PR31905.
-option(LLVM_INSTALL_MODULEMAPS "Install the modulemap files in the 'install' target." OFF)
-
-option(LLVM_USE_FOLDERS "Enable solution folders in Visual Studio. Disable for Express versions." ON)
-if ( LLVM_USE_FOLDERS )
-  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
-endif()
-
-include(VersionFromVCS)
-
-option(LLVM_APPEND_VC_REV
-  "Embed the version control system revision in LLVM" ON)
-
-set(PACKAGE_NAME LLVM)
-set(PACKAGE_STRING "${PACKAGE_NAME} ${PACKAGE_VERSION}")
-set(PACKAGE_BUGREPORT "https://github.com/llvm/llvm-project/issues/")
-
-set(BUG_REPORT_URL "${PACKAGE_BUGREPORT}" CACHE STRING
-  "Default URL where bug reports are to be submitted.")
-
-# Configure CPack.
-set(CPACK_PACKAGE_INSTALL_DIRECTORY "LLVM")
-set(CPACK_PACKAGE_VENDOR "LLVM")
-set(CPACK_PACKAGE_VERSION_MAJOR ${LLVM_VERSION_MAJOR})
-set(CPACK_PACKAGE_VERSION_MINOR ${LLVM_VERSION_MINOR})
-set(CPACK_PACKAGE_VERSION_PATCH ${LLVM_VERSION_PATCH})
-set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})
-set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.TXT")
-set(CPACK_NSIS_COMPRESSOR "/SOLID lzma \r\n SetCompressorDictSize 32")
-if(WIN32 AND NOT UNIX)
-  set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "LLVM")
-  set(CPACK_PACKAGE_ICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_logo.bmp")
-  set(CPACK_NSIS_MUI_ICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico")
-  set(CPACK_NSIS_MUI_UNIICON "${CMAKE_CURRENT_SOURCE_DIR}\\\\cmake\\\\nsis_icon.ico")
-  set(CPACK_NSIS_MODIFY_PATH "ON")
-  set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL "ON")
-  if( CMAKE_CL_64 )
-    set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES64")
-  endif()
-endif()
-include(CPack)
-
-# Sanity check our source directory to make sure that we are not trying to
-# generate an in-source build (unless on MSVC_IDE, where it is ok), and to make
-# sure that we don't have any stray generated files lying around in the tree
-# (which would end up getting picked up by header search, instead of the correct
-# versions).
-if( CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR AND NOT MSVC_IDE )
-  message(FATAL_ERROR "In-source builds are not allowed.
-Please create a directory and run cmake from there, passing the path
-to this source directory as the last argument.
-This process created the file `CMakeCache.txt' and the directory `CMakeFiles'.
-Please delete them.")
-endif()
-
-string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
-
-if (CMAKE_BUILD_TYPE AND
-    NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")
-  message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
-endif()
-
-set(LLVM_LIBDIR_SUFFIX "" CACHE STRING "Define suffix of library directory name (32/64)" )
-
-set(LLVM_TOOLS_INSTALL_DIR "${CMAKE_INSTALL_BINDIR}" CACHE STRING
-    "Path for binary subdirectory (defaults to '${CMAKE_INSTALL_BINDIR}')")
-mark_as_advanced(LLVM_TOOLS_INSTALL_DIR)
-
-set(LLVM_UTILS_INSTALL_DIR "${LLVM_TOOLS_INSTALL_DIR}" CACHE STRING
-    "Path to install LLVM utilities (enabled by LLVM_INSTALL_UTILS=ON) (defaults to LLVM_TOOLS_INSTALL_DIR)")
-mark_as_advanced(LLVM_UTILS_INSTALL_DIR)
-
-set(LLVM_EXAMPLES_INSTALL_DIR "examples" CACHE STRING
-    "Path for examples subdirectory (enabled by LLVM_BUILD_EXAMPLES=ON) (defaults to 'examples')")
-mark_as_advanced(LLVM_EXAMPLES_INSTALL_DIR)
-
-# They are used as destination of target generators.
-set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin)
-set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib${LLVM_LIBDIR_SUFFIX})
-if(WIN32 OR CYGWIN)
-  # DLL platform -- put DLLs into bin.
-  set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR})
-else()
-  set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR})
-endif()
-
-# Each of them corresponds to llvm-config's.
-set(LLVM_TOOLS_BINARY_DIR ${LLVM_RUNTIME_OUTPUT_INTDIR}) # --bindir
-set(LLVM_LIBRARY_DIR      ${LLVM_LIBRARY_OUTPUT_INTDIR}) # --libdir
-set(LLVM_MAIN_SRC_DIR     ${CMAKE_CURRENT_SOURCE_DIR}  ) # --src-root
-set(LLVM_MAIN_INCLUDE_DIR ${LLVM_MAIN_SRC_DIR}/include ) # --includedir
-set(LLVM_BINARY_DIR       ${CMAKE_CURRENT_BINARY_DIR}  ) # --prefix
-
-set(LLVM_THIRD_PARTY_DIR  ${CMAKE_CURRENT_SOURCE_DIR}/../third-party)
-
-# Note: LLVM_CMAKE_DIR does not include generated files
-set(LLVM_CMAKE_DIR ${LLVM_MAIN_SRC_DIR}/cmake/modules)
-set(LLVM_EXAMPLES_BINARY_DIR ${LLVM_BINARY_DIR}/examples)
-set(LLVM_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/include)
-
-# List of all targets to be built by default:
-set(LLVM_ALL_TARGETS
-  AArch64
-  AMDGPU
-  ARM
-  AVR
-  BPF
-  Hexagon
-  Lanai
-  Mips
-  MSP430
-  NVPTX
-  PowerPC
-  RISCV
-  Sparc
-  SystemZ
-  VE
-  WebAssembly
-  X86
-  XCore
-  )
-
-# List of targets with JIT support:
-set(LLVM_TARGETS_WITH_JIT X86 PowerPC AArch64 ARM Mips SystemZ)
-
-set(LLVM_TARGETS_TO_BUILD "all"
-    CACHE STRING "Semicolon-separated list of targets to build, or \"all\".")
-
-set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ""
-    CACHE STRING "Semicolon-separated list of experimental targets to build.")
-
-option(BUILD_SHARED_LIBS
-  "Build all libraries as shared libraries instead of static" OFF)
-
-option(LLVM_ENABLE_BACKTRACES "Enable embedding backtraces on crash." ON)
-if(LLVM_ENABLE_BACKTRACES)
-  set(ENABLE_BACKTRACES 1)
-endif()
-
-option(LLVM_ENABLE_UNWIND_TABLES "Emit unwind tables for the libraries" ON)
-
-option(LLVM_ENABLE_CRASH_OVERRIDES "Enable crash overrides." ON)
-if(LLVM_ENABLE_CRASH_OVERRIDES)
-  set(ENABLE_CRASH_OVERRIDES 1)
-endif()
-
-option(LLVM_ENABLE_CRASH_DUMPS "Turn on memory dumps on crashes. Currently only implemented on Windows." OFF)
-
-set(WINDOWS_PREFER_FORWARD_SLASH_DEFAULT OFF)
-if (MINGW)
-  # Cygwin doesn't identify itself as Windows, and thus gets path::Style::posix
-  # as native path style, regardless of what this is set to.
-  set(WINDOWS_PREFER_FORWARD_SLASH_DEFAULT ON)
-endif()
-option(LLVM_WINDOWS_PREFER_FORWARD_SLASH "Prefer path names with forward slashes on Windows." ${WINDOWS_PREFER_FORWARD_SLASH_DEFAULT})
-
-option(LLVM_ENABLE_FFI "Use libffi to call external functions from the interpreter" OFF)
-set(FFI_LIBRARY_DIR "" CACHE PATH "Additional directory, where CMake should search for libffi.so")
-set(FFI_INCLUDE_DIR "" CACHE PATH "Additional directory, where CMake should search for ffi.h or ffi/ffi.h")
-
-set(LLVM_TARGET_ARCH "host"
-  CACHE STRING "Set target to use for LLVM JIT or use \"host\" for automatic detection.")
-
-option(LLVM_ENABLE_TERMINFO "Use terminfo database if available." ON)
-
-set(LLVM_ENABLE_LIBXML2 "ON" CACHE STRING "Use libxml2 if available. Can be ON, OFF, or FORCE_ON")
-
-option(LLVM_ENABLE_LIBEDIT "Use libedit if available." ON)
-
-option(LLVM_ENABLE_LIBPFM "Use libpfm for performance counters if available." ON)
-
-# On z/OS, threads cannot be used because TLS is not supported.
-if (CMAKE_SYSTEM_NAME MATCHES "OS390")
-  option(LLVM_ENABLE_THREADS "Use threads if available." OFF)
-else()
-  option(LLVM_ENABLE_THREADS "Use threads if available." ON)
-endif()
-
-set(LLVM_ENABLE_ZLIB "ON" CACHE STRING "Use zlib for compression/decompression if available. Can be ON, OFF, or FORCE_ON")
-
-set(LLVM_ENABLE_CURL "OFF" CACHE STRING "Use libcurl for the HTTP client if available. Can be ON, OFF, or FORCE_ON")
-
-set(LLVM_Z3_INSTALL_DIR "" CACHE STRING "Install directory of the Z3 solver.")
-
-option(LLVM_ENABLE_Z3_SOLVER
-  "Enable Support for the Z3 constraint solver in LLVM."
-  ${LLVM_ENABLE_Z3_SOLVER_DEFAULT}
-)
-
-if (LLVM_ENABLE_Z3_SOLVER)
-  find_package(Z3 4.7.1)
-
-  if (LLVM_Z3_INSTALL_DIR)
-    if (NOT Z3_FOUND)
-      message(FATAL_ERROR "Z3 >= 4.7.1 has not been found in LLVM_Z3_INSTALL_DIR: ${LLVM_Z3_INSTALL_DIR}.")
-    endif()
-  endif()
-
-  if (NOT Z3_FOUND)
-    message(FATAL_ERROR "LLVM_ENABLE_Z3_SOLVER cannot be enabled when Z3 is not available.")
-  endif()
-
-  set(LLVM_WITH_Z3 1)
-endif()
-
-set(LLVM_ENABLE_Z3_SOLVER_DEFAULT "${Z3_FOUND}")
-
-
-if( LLVM_TARGETS_TO_BUILD STREQUAL "all" )
-  set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} )
-endif()
-
-set(LLVM_TARGETS_TO_BUILD
-   ${LLVM_TARGETS_TO_BUILD}
-   ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD})
-list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)
-
-option(LLVM_ENABLE_PIC "Build Position-Independent Code" ON)
-option(LLVM_ENABLE_MODULES "Compile with C++ modules enabled." OFF)
-if(${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
-  option(LLVM_ENABLE_MODULE_DEBUGGING "Compile with -gmodules." ON)
-else()
-  option(LLVM_ENABLE_MODULE_DEBUGGING "Compile with -gmodules." OFF)
-endif()
-option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY "Compile with -fmodules-local-submodule-visibility." ON)
-option(LLVM_ENABLE_LIBCXX "Use libc++ if available." OFF)
-option(LLVM_STATIC_LINK_CXX_STDLIB "Statically link the standard library." OFF)
-option(LLVM_ENABLE_LLD "Use lld as C and C++ linker." OFF)
-option(LLVM_ENABLE_PEDANTIC "Compile with pedantic enabled." ON)
-option(LLVM_ENABLE_WERROR "Fail and stop if a warning is triggered." OFF)
-
-option(LLVM_ENABLE_DUMP "Enable dump functions even when assertions are disabled" OFF)
-
-if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
-  option(LLVM_ENABLE_ASSERTIONS "Enable assertions" OFF)
-else()
-  option(LLVM_ENABLE_ASSERTIONS "Enable assertions" ON)
-endif()
-
-option(LLVM_ENABLE_EXPENSIVE_CHECKS "Enable expensive checks" OFF)
-
-# While adding scalable vector support to LLVM, we temporarily want to
-# allow an implicit conversion of TypeSize to uint64_t, and to allow
-# code to get the fixed number of elements from a possibly scalable vector.
-# This CMake flag enables a more strict mode where it asserts that the type
-# is not a scalable vector type.
-#
-# Enabling this flag makes it easier to find cases where the compiler makes
-# assumptions on the size being 'fixed size', when building tests for
-# SVE/SVE2 or other scalable vector architectures.
-option(LLVM_ENABLE_STRICT_FIXED_SIZE_VECTORS
-       "Enable assertions that type is not scalable in implicit conversion from TypeSize to uint64_t and calls to getNumElements" OFF)
-
-set(LLVM_ABI_BREAKING_CHECKS "WITH_ASSERTS" CACHE STRING
-  "Enable abi-breaking checks.  Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF.")
-
-option(LLVM_FORCE_USE_OLD_TOOLCHAIN
-       "Set to ON to force using an old, unsupported host toolchain." OFF)
-
-set(LLVM_LOCAL_RPATH "" CACHE FILEPATH
-  "If set, an absolute path added as rpath on binaries that do not already contain an executable-relative rpath.")
-
-option(LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN
-       "Set to ON to only warn when using a toolchain which is about to be deprecated, instead of emitting an error." OFF)
-
-option(LLVM_USE_INTEL_JITEVENTS
-  "Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code"
-  OFF)
-
-if( LLVM_USE_INTEL_JITEVENTS )
-  # Verify we are on a supported platform
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Windows" AND NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR
-      "Intel JIT API support is available on Linux and Windows only.")
-  endif()
-endif( LLVM_USE_INTEL_JITEVENTS )
-
-option(LLVM_USE_OPROFILE
-  "Use opagent JIT interface to inform OProfile about JIT code" OFF)
-
-option(LLVM_EXTERNALIZE_DEBUGINFO
-  "Generate dSYM files and strip executables and libraries (Darwin Only)" OFF)
-
-set(LLVM_CODESIGNING_IDENTITY "" CACHE STRING
-  "Sign executables and dylibs with the given identity or skip if empty (Darwin Only)")
-
-# If enabled, verify we are on a platform that supports oprofile.
-if( LLVM_USE_OPROFILE )
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR "OProfile support is available on Linux only.")
-  endif( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-endif( LLVM_USE_OPROFILE )
-
-option(LLVM_USE_PERF
-  "Use perf JIT interface to inform perf about JIT code" OFF)
-
-# If enabled, verify we are on a platform that supports perf.
-if( LLVM_USE_PERF )
-  if( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-    message(FATAL_ERROR "perf support is available on Linux only.")
-  endif( NOT CMAKE_SYSTEM_NAME MATCHES "Linux" )
-endif( LLVM_USE_PERF )
-
-set(LLVM_USE_SANITIZER "" CACHE STRING
-  "Define the sanitizer used to build binaries and tests.")
-option(LLVM_OPTIMIZE_SANITIZED_BUILDS "Pass -O1 on debug sanitizer builds" ON)
-set(LLVM_UBSAN_FLAGS
-    "-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all"
-    CACHE STRING
-    "Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.")
-set(LLVM_LIB_FUZZING_ENGINE "" CACHE PATH
-  "Path to fuzzing library for linking with fuzz targets")
-
-option(LLVM_USE_SPLIT_DWARF
-  "Use -gsplit-dwarf when compiling llvm and --gdb-index when linking." OFF)
-
-# Define an option controlling whether we should build for 32-bit on 64-bit
-# platforms, where supported.
-if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES "AIX"))
-  # TODO: support other platforms and toolchains.
-  option(LLVM_BUILD_32_BITS "Build 32 bits executables and libraries." OFF)
-endif()
-
-# Define the default arguments to use with 'lit', and an option for the user to
-# override.
-set(LIT_ARGS_DEFAULT "-sv")
-if (MSVC_IDE OR XCODE)
-  set(LIT_ARGS_DEFAULT "${LIT_ARGS_DEFAULT} --no-progress-bar")
-endif()
-set(LLVM_LIT_ARGS "${LIT_ARGS_DEFAULT}" CACHE STRING "Default options for lit")
-
-# On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.
-if( WIN32 AND NOT CYGWIN )
-  set(LLVM_LIT_TOOLS_DIR "" CACHE PATH "Path to GnuWin32 tools")
-endif()
-
-set(LLVM_INTEGRATED_CRT_ALLOC "" CACHE PATH "Replace the Windows CRT allocator with any of {rpmalloc|mimalloc|snmalloc}. Only works with /MT enabled.")
-if(LLVM_INTEGRATED_CRT_ALLOC)
-  if(NOT WIN32)
-    message(FATAL_ERROR "LLVM_INTEGRATED_CRT_ALLOC is only supported on Windows.")
-  endif()
-  if(LLVM_USE_SANITIZER)
-    message(FATAL_ERROR "LLVM_INTEGRATED_CRT_ALLOC cannot be used along with LLVM_USE_SANITIZER!")
-  endif()
-  if(CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG")
-    message(FATAL_ERROR "The Debug target isn't supported along with LLVM_INTEGRATED_CRT_ALLOC!")
-  endif()
-endif()
-
-# Define options to control the inclusion and default build behavior for
-# components which may not strictly be necessary (tools, examples, and tests).
-#
-# This is primarily to support building smaller or faster project files.
-option(LLVM_INCLUDE_TOOLS "Generate build targets for the LLVM tools." ON)
-option(LLVM_BUILD_TOOLS
-  "Build the LLVM tools. If OFF, just generate build targets." ON)
-
-option(LLVM_INCLUDE_UTILS "Generate build targets for the LLVM utils." ON)
-option(LLVM_BUILD_UTILS
-  "Build LLVM utility binaries. If OFF, just generate build targets." ON)
-
-option(LLVM_INCLUDE_RUNTIMES "Generate build targets for the LLVM runtimes." ON)
-option(LLVM_BUILD_RUNTIMES
-  "Build the LLVM runtimes. If OFF, just generate build targets." ON)
-
-option(LLVM_BUILD_RUNTIME
-  "Build the LLVM runtime libraries." ON)
-option(LLVM_BUILD_EXAMPLES
-  "Build the LLVM example programs. If OFF, just generate build targets." OFF)
-option(LLVM_INCLUDE_EXAMPLES "Generate build targets for the LLVM examples" ON)
-
-if(LLVM_BUILD_EXAMPLES)
-  add_definitions(-DBUILD_EXAMPLES)
-endif(LLVM_BUILD_EXAMPLES)
-
-option(LLVM_BUILD_TESTS
-  "Build LLVM unit tests. If OFF, just generate build targets." OFF)
-option(LLVM_INCLUDE_TESTS "Generate build targets for the LLVM unit tests." ON)
-option(LLVM_INCLUDE_GO_TESTS "Include the Go bindings tests in test build targets." OFF)
-
-option(LLVM_BUILD_BENCHMARKS "Add LLVM benchmark targets to the list of default
-targets. If OFF, benchmarks still could be built using Benchmarks target." OFF)
-option(LLVM_INCLUDE_BENCHMARKS "Generate benchmark targets. If OFF, benchmarks can't be built." ON)
-
-option (LLVM_BUILD_DOCS "Build the llvm documentation." OFF)
-option (LLVM_INCLUDE_DOCS "Generate build targets for llvm documentation." ON)
-option (LLVM_ENABLE_DOXYGEN "Use doxygen to generate llvm API documentation." OFF)
-option (LLVM_ENABLE_SPHINX "Use Sphinx to generate llvm documentation." OFF)
-option (LLVM_ENABLE_OCAMLDOC "Build OCaml bindings documentation." ON)
-option (LLVM_ENABLE_BINDINGS "Build bindings." ON)
-
-set(LLVM_INSTALL_DOXYGEN_HTML_DIR "${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html"
-    CACHE STRING "Doxygen-generated HTML documentation install directory")
-set(LLVM_INSTALL_OCAMLDOC_HTML_DIR "${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html"
-    CACHE STRING "OCamldoc-generated HTML documentation install directory")
-
-option (LLVM_BUILD_EXTERNAL_COMPILER_RT
-  "Build compiler-rt as an external project." OFF)
-
-option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO
-  "Show target and host info when tools are invoked with --version." ON)
-
-# You can configure which libraries from LLVM you want to include in the
-# shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited
-# list of LLVM components. All component names handled by llvm-config are valid.
-if(NOT DEFINED LLVM_DYLIB_COMPONENTS)
-  set(LLVM_DYLIB_COMPONENTS "all" CACHE STRING
-    "Semicolon-separated list of components to include in libLLVM, or \"all\".")
-endif()
-
-if(MSVC)
-  option(LLVM_BUILD_LLVM_C_DYLIB "Build LLVM-C.dll (Windows only)" ON)
-  # Set this variable to OFF here so it can't be set with a command-line
-  # argument.
-  set (LLVM_LINK_LLVM_DYLIB OFF)
-  if (BUILD_SHARED_LIBS)
-    message(FATAL_ERROR "BUILD_SHARED_LIBS options is not supported on Windows.")
-  endif()
-else()
-  option(LLVM_LINK_LLVM_DYLIB "Link tools against the libllvm dynamic library" OFF)
-  option(LLVM_BUILD_LLVM_C_DYLIB "Build libllvm-c re-export library (Darwin only)" OFF)
-  set(LLVM_BUILD_LLVM_DYLIB_default OFF)
-  if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB)
-    set(LLVM_BUILD_LLVM_DYLIB_default ON)
-  endif()
-  option(LLVM_BUILD_LLVM_DYLIB "Build libllvm dynamic library" ${LLVM_BUILD_LLVM_DYLIB_default})
-endif()
-
-if (LLVM_LINK_LLVM_DYLIB AND BUILD_SHARED_LIBS)
-  message(FATAL_ERROR "Cannot enable BUILD_SHARED_LIBS with LLVM_LINK_LLVM_DYLIB.  We recommend disabling BUILD_SHARED_LIBS.")
-endif()
-
-option(LLVM_OPTIMIZED_TABLEGEN "Force TableGen to be built with optimization" OFF)
-if(CMAKE_CROSSCOMPILING OR (LLVM_OPTIMIZED_TABLEGEN AND (LLVM_ENABLE_ASSERTIONS OR CMAKE_CONFIGURATION_TYPES)))
-  set(LLVM_USE_HOST_TOOLS ON)
-endif()
-
-option(LLVM_OMIT_DAGISEL_COMMENTS "Do not add comments to DAG ISel" ON)
-if (CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE MATCHES "^(RELWITHDEBINFO|DEBUG)$")
-  set(LLVM_OMIT_DAGISEL_COMMENTS OFF)
-endif()
-
-if (MSVC_IDE)
-  option(LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION "Configure project to use Visual Studio native visualizers" TRUE)
-endif()
-
-if (LLVM_BUILD_INSTRUMENTED OR LLVM_BUILD_INSTRUMENTED_COVERAGE OR
-    LLVM_ENABLE_IR_PGO)
-  if(NOT LLVM_PROFILE_MERGE_POOL_SIZE)
-    # A pool size of 1-2 is probably sufficient on a SSD. 3-4 should be fine
-    # for spining disks. Anything higher may only help on slower mediums.
-    set(LLVM_PROFILE_MERGE_POOL_SIZE "4")
-  endif()
-  if(NOT LLVM_PROFILE_FILE_PATTERN)
-    if(NOT LLVM_PROFILE_DATA_DIR)
-      file(TO_NATIVE_PATH "${LLVM_BINARY_DIR}/profiles" LLVM_PROFILE_DATA_DIR)
-    endif()
-    file(TO_NATIVE_PATH "${LLVM_PROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw" LLVM_PROFILE_FILE_PATTERN)
-  endif()
-  if(NOT LLVM_CSPROFILE_FILE_PATTERN)
-    if(NOT LLVM_CSPROFILE_DATA_DIR)
-      file(TO_NATIVE_PATH "${LLVM_BINARY_DIR}/csprofiles" LLVM_CSPROFILE_DATA_DIR)
-    endif()
-    file(TO_NATIVE_PATH "${LLVM_CSPROFILE_DATA_DIR}/%${LLVM_PROFILE_MERGE_POOL_SIZE}m.profraw" LLVM_CSPROFILE_FILE_PATTERN)
-  endif()
-endif()
-
-if (LLVM_BUILD_STATIC)
-  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -static")
-  # Remove shared library suffixes from use in find_library
-  foreach (shared_lib_suffix ${CMAKE_SHARED_LIBRARY_SUFFIX} ${CMAKE_IMPORT_LIBRARY_SUFFIX})
-    list(FIND CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix} shared_lib_suffix_idx)
-    if(NOT ${shared_lib_suffix_idx} EQUAL -1)
-      list(REMOVE_AT CMAKE_FIND_LIBRARY_SUFFIXES ${shared_lib_suffix_idx})
-    endif()
-  endforeach()
-endif()
-
-# Use libtool instead of ar if you are both on an Apple host, and targeting Apple.
-if(CMAKE_HOST_APPLE AND APPLE)
-  include(UseLibtool)
-endif()
-
-# Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.
-set(LLVM_TARGET_TRIPLE_ENV CACHE STRING "The name of environment variable to override default target. Disabled by blank.")
-mark_as_advanced(LLVM_TARGET_TRIPLE_ENV)
-
-set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR OFF CACHE BOOL
-  "Enable per-target runtimes directory")
-
-set(LLVM_PROFDATA_FILE "" CACHE FILEPATH
-  "Profiling data file to use when compiling in order to improve runtime performance.")
-
-# All options referred to from HandleLLVMOptions have to be specified
-# BEFORE this include, otherwise options will not be correctly set on
-# first cmake run
-include(config-ix)
-
-# By default, we target the host, but this can be overridden at CMake
-# invocation time. Except on 64-bit AIX, where the system toolchain
-# expect 32-bit objects by default.
-if("${LLVM_HOST_TRIPLE}" MATCHES "^powerpc64-ibm-aix")
-  string(REGEX REPLACE "^powerpc64" "powerpc" LLVM_DEFAULT_TARGET_TRIPLE_default "${LLVM_HOST_TRIPLE}")
-else()
-  set(LLVM_DEFAULT_TARGET_TRIPLE_default "${LLVM_HOST_TRIPLE}")
-endif()
-
-set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_DEFAULT_TARGET_TRIPLE_default}" CACHE STRING
-  "Default target for which LLVM will generate code." )
-set(TARGET_TRIPLE "${LLVM_DEFAULT_TARGET_TRIPLE}")
-message(STATUS "LLVM host triple: ${LLVM_HOST_TRIPLE}")
-message(STATUS "LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}")
-
-if(WIN32 OR CYGWIN)
-  if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB)
-    set(LLVM_ENABLE_PLUGINS_default ON)
-  else()
-    set(LLVM_ENABLE_PLUGINS_default OFF)
-  endif()
-else()
-  set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC})
-endif()
-option(LLVM_ENABLE_PLUGINS "Enable plugin support" ${LLVM_ENABLE_PLUGINS_default})
-
-set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL
-  "Enable the new pass manager by default.")
-if(NOT LLVM_ENABLE_NEW_PASS_MANAGER)
-  message(WARNING "Using the legacy pass manager for the optimization pipeline"
-                  " is deprecated. The functionality will degrade over time and"
-                  " be removed in a future release.")
-endif()
-
-include(HandleLLVMOptions)
-
-find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED
-    COMPONENTS Interpreter)
-
-######
-
-# Configure all of the various header file fragments LLVM uses which depend on
-# configuration variables.
-set(LLVM_ENUM_TARGETS "")
-set(LLVM_ENUM_ASM_PRINTERS "")
-set(LLVM_ENUM_ASM_PARSERS "")
-set(LLVM_ENUM_DISASSEMBLERS "")
-set(LLVM_ENUM_TARGETMCAS "")
-foreach(t ${LLVM_TARGETS_TO_BUILD})
-  set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} )
-
-  list(FIND LLVM_ALL_TARGETS ${t} idx)
-  list(FIND LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${t} idy)
-  # At this point, LLVMBUILDTOOL already checked all the targets passed in
-  # LLVM_TARGETS_TO_BUILD and LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, so
-  # this test just makes sure that any experimental targets were passed via
-  # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.
-  if( idx LESS 0 AND idy LESS 0 )
-    message(FATAL_ERROR "The target `${t}' is experimental and must be passed "
-      "via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.")
-  else()
-    set(LLVM_ENUM_TARGETS "${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\n")
-  endif()
-
-  file(GLOB asmp_file "${td}/*AsmPrinter.cpp")
-  if( asmp_file )
-    set(LLVM_ENUM_ASM_PRINTERS
-      "${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n")
-  endif()
-  if( EXISTS ${td}/AsmParser/CMakeLists.txt )
-    set(LLVM_ENUM_ASM_PARSERS
-      "${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\n")
-  endif()
-  if( EXISTS ${td}/Disassembler/CMakeLists.txt )
-    set(LLVM_ENUM_DISASSEMBLERS
-      "${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\n")
-  endif()
-    if( EXISTS ${td}/MCA/CMakeLists.txt )
-    set(LLVM_ENUM_TARGETMCAS
-      "${LLVM_ENUM_TARGETMCAS}LLVM_TARGETMCA(${t})\n")
-  endif()
-endforeach(t)
-
-# Provide an LLVM_ namespaced alias for use in #cmakedefine.
-set(LLVM_BUILD_SHARED_LIBS ${BUILD_SHARED_LIBS})
-
-# Produce the target definition files, which provide a way for clients to easily
-# include various classes of targets.
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmPrinters.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/AsmPrinters.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmParsers.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/AsmParsers.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Disassemblers.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/Disassemblers.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def
-  )
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in
-  ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def
-  )
-
-# They are not referenced. See set_output_directory().
-set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/bin )
-set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} )
-
-if(LLVM_INCLUDE_TESTS)
-  include(GetErrcMessages)
-  get_errc_messages(LLVM_LIT_ERRC_MESSAGES)
-endif()
-
-# For up-to-date instructions for installing the Tensorflow dependency, refer to
-# the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh
-# In this case, the latest C API library is available for download from
-# https://www.tensorflow.org/install/lang_c.
-# We will expose the conditional compilation variable,
-# LLVM_HAVE_TF_API, through llvm-config.h, so that a user of the LLVM library may
-# also leverage the dependency.
-set(TENSORFLOW_C_LIB_PATH "" CACHE PATH "Path to TensorFlow C library install")
-if (TENSORFLOW_C_LIB_PATH)
-  find_library(tensorflow_c_api tensorflow PATHS ${TENSORFLOW_C_LIB_PATH}/lib NO_DEFAULT_PATH REQUIRED)
-  # Currently, the protobuf headers are distributed with the pip package that corresponds to the version
-  # of the C API library.
-  find_library(tensorflow_fx tensorflow_framework PATHS ${TENSORFLOW_C_LIB_PATH}/lib NO_DEFAULT_PATH REQUIRED)
-  set(LLVM_HAVE_TF_API "ON" CACHE BOOL "Full Tensorflow API available")
-  include_directories(${TENSORFLOW_C_LIB_PATH}/include)
-  if (NOT TF_PROTO_HEADERS)
-    message(STATUS "TF_PROTO_HEADERS not defined. Looking for tensorflow pip package.")
-    execute_process(COMMAND
-      ${Python3_EXECUTABLE} "-m" "pip" "show" "tensorflow"
-      OUTPUT_VARIABLE TF_PIP_OUT)
-    if ("${TF_PIP_OUT}" STREQUAL "")
-      message(FATAL ERROR "Tensorflow pip package is also required for 'development' mode (protobuf headers)")
-    endif()
-    string(REGEX MATCH "Location: ([^\n]*\n)" TF_PIP_LOC "${TF_PIP_OUT}")
-    string(REPLACE "Location: " "" TF_PIP ${TF_PIP_LOC})
-    string(STRIP ${TF_PIP} TF_PIP)
-    set(TF_PROTO_HEADERS "${TF_PIP}/tensorflow/include")
-  endif()
-  message(STATUS "Using Tensorflow headers under: ${TF_PROTO_HEADERS}")
-  include_directories(${TF_PROTO_HEADERS})
-  add_definitions("-DGOOGLE_PROTOBUF_NO_RTTI")
-  add_definitions("-D_GLIBCXX_USE_CXX11_ABI=0")
-endif()
-
-# For up-to-date instructions for installing the Tensorflow dependency, refer to
-# the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh
-# Specifically, assuming python3 is installed:
-# python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528
-# Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow
-#
-set(TENSORFLOW_AOT_PATH "" CACHE PATH "Path to TensorFlow pip install dir")
-
-if (NOT TENSORFLOW_AOT_PATH STREQUAL "")
-  set(LLVM_HAVE_TF_AOT "ON" CACHE BOOL "Tensorflow AOT available")
-  set(TENSORFLOW_AOT_COMPILER
-    "${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli"
-    CACHE PATH "Path to the Tensorflow AOT compiler")
-  include_directories(${TENSORFLOW_AOT_PATH}/include)
-  add_subdirectory(${TENSORFLOW_AOT_PATH}/xla_aot_runtime_src
-    ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/tf_runtime)
-  install(TARGETS tf_xla_runtime EXPORT LLVMExports
-    ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtime)
-  set_property(GLOBAL APPEND PROPERTY LLVM_EXPORTS tf_xla_runtime)
-  # Once we add more modules, we should handle this more automatically.
-  if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_INLINERSIZEMODEL)
-    set(LLVM_INLINER_MODEL_PATH "none")
-  elseif(NOT DEFINED LLVM_INLINER_MODEL_PATH
-      OR "${LLVM_INLINER_MODEL_PATH}" STREQUAL ""
-      OR "${LLVM_INLINER_MODEL_PATH}" STREQUAL "autogenerate")
-    set(LLVM_INLINER_MODEL_PATH "autogenerate")
-    set(LLVM_INLINER_MODEL_AUTOGENERATED 1)
-  endif()
-  if (DEFINED LLVM_OVERRIDE_MODEL_HEADER_REGALLOCEVICTMODEL)
-    set(LLVM_RAEVICT_MODEL_PATH "none")
-  elseif(NOT DEFINED LLVM_RAEVICT_MODEL_PATH
-      OR "${LLVM_RAEVICT_MODEL_PATH}" STREQUAL ""
-      OR "${LLVM_RAEVICT_MODEL_PATH}" STREQUAL "autogenerate")
-    set(LLVM_RAEVICT_MODEL_PATH "autogenerate")
-    set(LLVM_RAEVICT_MODEL_AUTOGENERATED 1)
-  endif()
-
-endif()
-
-# Configure the three LLVM configuration header files.
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/config.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/config.h)
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/llvm-config.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/llvm-config.h)
-configure_file(
-  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/abi-breaking.h.cmake
-  ${LLVM_INCLUDE_DIR}/llvm/Config/abi-breaking.h)
-
-# Add target for generating source rpm package.
-set(LLVM_SRPM_USER_BINARY_SPECFILE ${CMAKE_CURRENT_SOURCE_DIR}/llvm.spec.in
-    CACHE FILEPATH ".spec file to use for srpm generation")
-set(LLVM_SRPM_BINARY_SPECFILE ${CMAKE_CURRENT_BINARY_DIR}/llvm.spec)
-set(LLVM_SRPM_DIR "${CMAKE_CURRENT_BINARY_DIR}/srpm")
-
-get_source_info(${CMAKE_CURRENT_SOURCE_DIR} revision repository)
-string(LENGTH "${revision}" revision_length)
-set(LLVM_RPM_SPEC_REVISION "${revision}")
-
-configure_file(
-  ${LLVM_SRPM_USER_BINARY_SPECFILE}
-  ${LLVM_SRPM_BINARY_SPECFILE} @ONLY)
-
-add_custom_target(srpm
-  COMMAND cpack -G TGZ --config CPackSourceConfig.cmake -B ${LLVM_SRPM_DIR}/SOURCES
-  COMMAND rpmbuild -bs --define '_topdir ${LLVM_SRPM_DIR}' ${LLVM_SRPM_BINARY_SPECFILE})
-set_target_properties(srpm PROPERTIES FOLDER "Misc")
-
-if(APPLE AND DARWIN_LTO_LIBRARY)
-  set(CMAKE_EXE_LINKER_FLAGS
-    "${CMAKE_EXE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-  set(CMAKE_SHARED_LINKER_FLAGS
-    "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-  set(CMAKE_MODULE_LINKER_FLAGS
-    "${CMAKE_MODULE_LINKER_FLAGS} -Wl,-lto_library -Wl,${DARWIN_LTO_LIBRARY}")
-endif()
-
-# Build with _XOPEN_SOURCE on AIX, as stray macros in _ALL_SOURCE mode tend to
-# break things. In this case we need to enable the large-file API as well.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "AIX")
-          add_definitions("-D_XOPEN_SOURCE=700")
-          add_definitions("-D_LARGE_FILE_API")
-
-  # CMake versions less than 3.16 set default linker flags to include -brtl, as
-  # well as setting -G when building libraries, so clear them out. Note we only
-  # try to clear the form that CMake will set as part of its initial
-  # configuration, it is still possible the user may force it as part of a
-  # compound option.
-  if(CMAKE_VERSION VERSION_LESS 3.16)
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_SHARED_LINKER_FLAGS  "${CMAKE_SHARED_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-brtl([ \t]+|$)" " " CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)(-Wl,)?-G([ \t]+|$)" " " CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS}")
-    string(REGEX REPLACE "(^|[ \t]+)-Wl,-G," " -Wl," CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS
-      "${CMAKE_SHARED_LIBRARY_CREATE_ASM_FLAGS}")
-  endif()
-
-  # Modules should be built with -shared -Wl,-G, so we can use runtime linking
-  # with plugins.
-  string(APPEND CMAKE_MODULE_LINKER_FLAGS " -shared -Wl,-G")
-
-  # Also set the correct flags for building shared libraries.
-  string(APPEND CMAKE_SHARED_LINKER_FLAGS " -shared")
-endif()
-
-# Build with _XOPEN_SOURCE on z/OS.
-if (CMAKE_SYSTEM_NAME MATCHES "OS390")
-  add_definitions("-D_XOPEN_SOURCE=600")
-  add_definitions("-D_OPEN_SYS") # Needed for process information.
-  add_definitions("-D_OPEN_SYS_FILE_EXT") # Needed for EBCDIC I/O.
-endif()
-
-# Build with _FILE_OFFSET_BITS=64 on Solaris to match g++ >= 9.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "SunOS")
-          add_definitions("-D_FILE_OFFSET_BITS=64")
-endif()
-
-set(CMAKE_INCLUDE_CURRENT_DIR ON)
-
-include_directories( ${LLVM_INCLUDE_DIR} ${LLVM_MAIN_INCLUDE_DIR})
-
-# when crosscompiling import the executable targets from a file
-if(LLVM_USE_HOST_TOOLS)
-  include(CrossCompile)
-  llvm_create_cross_target(LLVM NATIVE "" Release)
-endif(LLVM_USE_HOST_TOOLS)
-if(LLVM_TARGET_IS_CROSSCOMPILE_HOST)
-# Dummy use to avoid CMake Warning: Manually-specified variables were not used
-# (this is a variable that CrossCompile sets on recursive invocations)
-endif()
-
-if( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )
-   # special hack for Solaris to handle crazy system sys/regset.h
-   include_directories("${LLVM_MAIN_INCLUDE_DIR}/llvm/Support/Solaris")
-endif( ${CMAKE_SYSTEM_NAME} MATCHES SunOS )
-
-# Make sure we don't get -rdynamic in every binary. For those that need it,
-# use export_executable_symbols(target).
-set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
-
-set(LLVM_EXTRACT_SYMBOLS_FLAGS ""
-  CACHE STRING "Additional options to pass to llvm/utils/extract_symbols.py.
-  These cannot override the options set by cmake, but can add extra options
-  such as --tools.")
-
-include(AddLLVM)
-include(TableGen)
-
-include(LLVMDistributionSupport)
-
-if( MINGW AND NOT "${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang" )
-  # People report that -O3 is unreliable on MinGW. The traditional
-  # build also uses -O2 for that reason:
-  llvm_replace_compiler_option(CMAKE_CXX_FLAGS_RELEASE "-O3" "-O2")
-endif()
-
-# Put this before tblgen. Else we have a circular dependence.
-add_subdirectory(lib/Demangle)
-add_subdirectory(lib/Support)
-add_subdirectory(lib/TableGen)
-
-add_subdirectory(utils/TableGen)
-
-add_subdirectory(include/llvm)
-
-add_subdirectory(lib)
-
-if( LLVM_INCLUDE_UTILS )
-  add_subdirectory(utils/FileCheck)
-  add_subdirectory(utils/PerfectShuffle)
-  add_subdirectory(utils/count)
-  add_subdirectory(utils/not)
-  add_subdirectory(utils/yaml-bench)
-else()
-  if ( LLVM_INCLUDE_TESTS )
-    message(FATAL_ERROR "Including tests when not building utils will not work.
-    Either set LLVM_INCLUDE_UTILS to On, or set LLVM_INCLUDE_TESTS to Off.")
-  endif()
-endif()
-
-# Use LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION instead of LLVM_INCLUDE_UTILS because it is not really a util
-if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION)
-  add_subdirectory(utils/LLVMVisualizers)
-endif()
-
-foreach( binding ${LLVM_BINDINGS_LIST} )
-  if( EXISTS "${LLVM_MAIN_SRC_DIR}/bindings/${binding}/CMakeLists.txt" )
-    add_subdirectory(bindings/${binding})
-  endif()
-endforeach()
-
-add_subdirectory(projects)
-
-if( LLVM_INCLUDE_TOOLS )
-  add_subdirectory(tools)
-endif()
-
-if( LLVM_INCLUDE_RUNTIMES )
-  add_subdirectory(runtimes)
-endif()
-
-if( LLVM_INCLUDE_EXAMPLES )
-  add_subdirectory(examples)
-endif()
-
-if( LLVM_INCLUDE_TESTS )
-  if(EXISTS ${LLVM_MAIN_SRC_DIR}/projects/test-suite AND TARGET clang)
-    include(LLVMExternalProjectUtils)
-    llvm_ExternalProject_Add(test-suite ${LLVM_MAIN_SRC_DIR}/projects/test-suite
-      USE_TOOLCHAIN
-      EXCLUDE_FROM_ALL
-      NO_INSTALL
-      ALWAYS_CLEAN)
-  endif()
-  add_subdirectory(utils/lit)
-  add_subdirectory(test)
-  add_subdirectory(unittests)
-  if( LLVM_INCLUDE_UTILS )
-    add_subdirectory(utils/unittest)
-  endif()
-
-  if (WIN32)
-    # This utility is used to prevent crashing tests from calling Dr. Watson on
-    # Windows.
-    add_subdirectory(utils/KillTheDoctor)
-  endif()
-
-  # Add a global check rule now that all subdirectories have been traversed
-  # and we know the total set of lit testsuites.
-  get_property(LLVM_LIT_TESTSUITES GLOBAL PROPERTY LLVM_LIT_TESTSUITES)
-  get_property(LLVM_LIT_PARAMS GLOBAL PROPERTY LLVM_LIT_PARAMS)
-  get_property(LLVM_LIT_DEPENDS GLOBAL PROPERTY LLVM_LIT_DEPENDS)
-  get_property(LLVM_LIT_EXTRA_ARGS GLOBAL PROPERTY LLVM_LIT_EXTRA_ARGS)
-  get_property(LLVM_ADDITIONAL_TEST_TARGETS
-               GLOBAL PROPERTY LLVM_ADDITIONAL_TEST_TARGETS)
-  get_property(LLVM_ADDITIONAL_TEST_DEPENDS
-               GLOBAL PROPERTY LLVM_ADDITIONAL_TEST_DEPENDS)
-  add_lit_target(check-all
-    "Running all regression tests"
-    ${LLVM_LIT_TESTSUITES}
-    PARAMS ${LLVM_LIT_PARAMS}
-    DEPENDS ${LLVM_LIT_DEPENDS} ${LLVM_ADDITIONAL_TEST_TARGETS}
-    ARGS ${LLVM_LIT_EXTRA_ARGS}
-    )
-  if(TARGET check-runtimes)
-    add_dependencies(check-all check-runtimes)
-  endif()
-  add_custom_target(test-depends
-                    DEPENDS ${LLVM_LIT_DEPENDS} ${LLVM_ADDITIONAL_TEST_DEPENDS})
-  set_target_properties(test-depends PROPERTIES FOLDER "Tests")
-endif()
-
-if (LLVM_INCLUDE_DOCS)
-  add_subdirectory(docs)
-endif()
-
-add_subdirectory(cmake/modules)
-
-# Do this last so that all lit targets have already been created.
-if (LLVM_INCLUDE_UTILS)
-  add_subdirectory(utils/llvm-lit)
-endif()
-
-if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY)
-  install(DIRECTORY include/llvm include/llvm-c
-    DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
-    COMPONENT llvm-headers
-    FILES_MATCHING
-    PATTERN "*.def"
-    PATTERN "*.h"
-    PATTERN "*.td"
-    PATTERN "*.inc"
-    PATTERN "LICENSE.TXT"
-    )
-
-  install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c
-    DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
-    COMPONENT llvm-headers
-    FILES_MATCHING
-    PATTERN "*.def"
-    PATTERN "*.h"
-    PATTERN "*.gen"
-    PATTERN "*.inc"
-    # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by "*.def"
-    PATTERN "CMakeFiles" EXCLUDE
-    PATTERN "config.h" EXCLUDE
-    )
-
-  if (LLVM_INSTALL_MODULEMAPS)
-    install(DIRECTORY include/llvm include/llvm-c
-            DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
-            COMPONENT llvm-headers
-            FILES_MATCHING
-            PATTERN "module.modulemap"
-            )
-    install(FILES include/llvm/module.install.modulemap
-            DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/llvm"
-            COMPONENT llvm-headers
-            RENAME "module.extern.modulemap"
-            )
-  endif(LLVM_INSTALL_MODULEMAPS)
-
-  # Installing the headers needs to depend on generating any public
-  # tablegen'd headers.
-  add_custom_target(llvm-headers DEPENDS intrinsics_gen omp_gen)
-  set_target_properties(llvm-headers PROPERTIES FOLDER "Misc")
-
-  if (NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-llvm-headers
-                             DEPENDS llvm-headers
-                             COMPONENT llvm-headers)
-  endif()
-
-  # Custom target to install all libraries.
-  add_custom_target(llvm-libraries)
-  set_target_properties(llvm-libraries PROPERTIES FOLDER "Misc")
-
-  if (NOT LLVM_ENABLE_IDE)
-    add_llvm_install_targets(install-llvm-libraries
-                             DEPENDS llvm-libraries
-                             COMPONENT llvm-libraries)
-  endif()
-
-  get_property(LLVM_LIBS GLOBAL PROPERTY LLVM_LIBS)
-  if(LLVM_LIBS)
-    list(REMOVE_DUPLICATES LLVM_LIBS)
-    foreach(lib ${LLVM_LIBS})
-      add_dependencies(llvm-libraries ${lib})
-      if (NOT LLVM_ENABLE_IDE)
-        add_dependencies(install-llvm-libraries install-${lib})
-        add_dependencies(install-llvm-libraries-stripped install-${lib}-stripped)
-      endif()
-    endforeach()
-  endif()
-endif()
-
-# This must be at the end of the LLVM root CMakeLists file because it must run
-# after all targets are created.
-llvm_distribution_add_targets()
-process_llvm_pass_plugins(GEN_CONFIG)
-include(CoverageReport)
-
-# This allows us to deploy the Universal CRT DLLs by passing -DCMAKE_INSTALL_UCRT_LIBRARIES=ON to CMake
-if (MSVC AND CMAKE_HOST_SYSTEM_NAME STREQUAL "Windows" AND CMAKE_INSTALL_UCRT_LIBRARIES)
-  include(InstallRequiredSystemLibraries)
-endif()
-
-if (LLVM_INCLUDE_BENCHMARKS)
-  # Override benchmark defaults so that when the library itself is updated these
-  # modifications are not lost.
-  set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "Disable benchmark testing" FORCE)
-  set(BENCHMARK_ENABLE_EXCEPTIONS OFF CACHE BOOL "Disable benchmark exceptions" FORCE)
-  set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL "Don't install benchmark" FORCE)
-  set(BENCHMARK_DOWNLOAD_DEPENDENCIES OFF CACHE BOOL "Don't download dependencies" FORCE)
-  set(BENCHMARK_ENABLE_GTEST_TESTS OFF CACHE BOOL "Disable Google Test in benchmark" FORCE)
-  set(BENCHMARK_ENABLE_WERROR ${LLVM_ENABLE_WERROR} CACHE BOOL 
-    "Handle -Werror for Google Benchmark based on LLVM_ENABLE_WERROR" FORCE)
-  # Since LLVM requires C++11 it is safe to assume that std::regex is available.
-  set(HAVE_STD_REGEX ON CACHE BOOL "OK" FORCE)
-  add_subdirectory(${LLVM_THIRD_PARTY_DIR}/benchmark 
-    ${CMAKE_CURRENT_BINARY_DIR}/third-party/benchmark)
-  add_subdirectory(benchmarks)
-endif()
-
-if (LLVM_INCLUDE_UTILS AND LLVM_INCLUDE_TOOLS)
-  add_subdirectory(utils/llvm-locstats)
-endif()
diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
new file mode 120000
index 000000000000..6ada06c9bdea
--- /dev/null
+++ b/llvm/CMakeLists.txt
@@ -0,0 +1 @@
+/home/ormastes/dev/pri/toy-riscv-backend/llvm/CMakeLists.txt
\ No newline at end of file
diff --git a/llvm/cmake/config-ix.cmake b/llvm/cmake/config-ix.cmake
deleted file mode 100644
index 18d78879c968..000000000000
--- a/llvm/cmake/config-ix.cmake
+++ /dev/null
@@ -1,729 +0,0 @@
-if( WIN32 AND NOT CYGWIN )
-  # We consider Cygwin as another Unix
-  set(PURE_WINDOWS 1)
-endif()
-
-include(CheckIncludeFile)
-include(CheckLibraryExists)
-include(CheckSymbolExists)
-include(CheckFunctionExists)
-include(CheckStructHasMember)
-include(CheckCCompilerFlag)
-include(CMakePushCheckState)
-
-include(CheckCompilerVersion)
-include(HandleLLVMStdlib)
-
-if( UNIX AND NOT (APPLE OR BEOS OR HAIKU) )
-  # Used by check_symbol_exists:
-  list(APPEND CMAKE_REQUIRED_LIBRARIES "m")
-endif()
-# x86_64 FreeBSD 9.2 requires libcxxrt to be specified explicitly.
-if( CMAKE_SYSTEM MATCHES "FreeBSD-9.2-RELEASE" AND
-    CMAKE_SIZEOF_VOID_P EQUAL 8 )
-  list(APPEND CMAKE_REQUIRED_LIBRARIES "cxxrt")
-endif()
-
-# Do checks with _XOPEN_SOURCE and large-file API on AIX, because we will build
-# with those too.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "AIX")
-          list(APPEND CMAKE_REQUIRED_DEFINITIONS "-D_XOPEN_SOURCE=700")
-          list(APPEND CMAKE_REQUIRED_DEFINITIONS "-D_LARGE_FILE_API")
-endif()
-
-# Do checks with _FILE_OFFSET_BITS=64 on Solaris, because we will build
-# with those too.
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "SunOS")
-          list(APPEND CMAKE_REQUIRED_DEFINITIONS "-D_FILE_OFFSET_BITS=64")
-endif()
-
-# include checks
-check_include_file(dlfcn.h HAVE_DLFCN_H)
-check_include_file(errno.h HAVE_ERRNO_H)
-check_include_file(fcntl.h HAVE_FCNTL_H)
-check_include_file(link.h HAVE_LINK_H)
-check_include_file(malloc/malloc.h HAVE_MALLOC_MALLOC_H)
-if( NOT PURE_WINDOWS )
-  check_include_file(pthread.h HAVE_PTHREAD_H)
-endif()
-check_include_file(signal.h HAVE_SIGNAL_H)
-check_include_file(sys/ioctl.h HAVE_SYS_IOCTL_H)
-check_include_file(sys/mman.h HAVE_SYS_MMAN_H)
-check_include_file(sys/param.h HAVE_SYS_PARAM_H)
-check_include_file(sys/resource.h HAVE_SYS_RESOURCE_H)
-check_include_file(sys/stat.h HAVE_SYS_STAT_H)
-check_include_file(sys/time.h HAVE_SYS_TIME_H)
-check_include_file(sys/types.h HAVE_SYS_TYPES_H)
-check_include_file(sysexits.h HAVE_SYSEXITS_H)
-check_include_file(termios.h HAVE_TERMIOS_H)
-check_include_file(unistd.h HAVE_UNISTD_H)
-check_include_file(valgrind/valgrind.h HAVE_VALGRIND_VALGRIND_H)
-check_include_file(fenv.h HAVE_FENV_H)
-check_symbol_exists(FE_ALL_EXCEPT "fenv.h" HAVE_DECL_FE_ALL_EXCEPT)
-check_symbol_exists(FE_INEXACT "fenv.h" HAVE_DECL_FE_INEXACT)
-
-check_include_file(mach/mach.h HAVE_MACH_MACH_H)
-check_include_file(histedit.h HAVE_HISTEDIT_H)
-check_include_file(CrashReporterClient.h HAVE_CRASHREPORTERCLIENT_H)
-if(APPLE)
-  include(CheckCSourceCompiles)
-  CHECK_C_SOURCE_COMPILES("
-     static const char *__crashreporter_info__ = 0;
-     asm(\".desc ___crashreporter_info__, 0x10\");
-     int main() { return 0; }"
-    HAVE_CRASHREPORTER_INFO)
-endif()
-
-if(${CMAKE_SYSTEM_NAME} STREQUAL "Linux")
-  check_include_file(linux/magic.h HAVE_LINUX_MAGIC_H)
-  if(NOT HAVE_LINUX_MAGIC_H)
-    # older kernels use split files
-    check_include_file(linux/nfs_fs.h HAVE_LINUX_NFS_FS_H)
-    check_include_file(linux/smb.h HAVE_LINUX_SMB_H)
-  endif()
-endif()
-
-# library checks
-if( NOT PURE_WINDOWS )
-  check_library_exists(pthread pthread_create "" HAVE_LIBPTHREAD)
-  if (HAVE_LIBPTHREAD)
-    check_library_exists(pthread pthread_getspecific "" HAVE_PTHREAD_GETSPECIFIC)
-    check_library_exists(pthread pthread_rwlock_init "" HAVE_PTHREAD_RWLOCK_INIT)
-    check_library_exists(pthread pthread_mutex_lock "" HAVE_PTHREAD_MUTEX_LOCK)
-  else()
-    # this could be Android
-    check_library_exists(c pthread_create "" PTHREAD_IN_LIBC)
-    if (PTHREAD_IN_LIBC)
-      check_library_exists(c pthread_getspecific "" HAVE_PTHREAD_GETSPECIFIC)
-      check_library_exists(c pthread_rwlock_init "" HAVE_PTHREAD_RWLOCK_INIT)
-      check_library_exists(c pthread_mutex_lock "" HAVE_PTHREAD_MUTEX_LOCK)
-    endif()
-  endif()
-  check_library_exists(dl dlopen "" HAVE_LIBDL)
-  check_library_exists(rt clock_gettime "" HAVE_LIBRT)
-endif()
-
-# Check for libpfm.
-include(FindLibpfm)
-
-if(HAVE_LIBPTHREAD)
-  # We want to find pthreads library and at the moment we do want to
-  # have it reported as '-l<lib>' instead of '-pthread'.
-  # TODO: switch to -pthread once the rest of the build system can deal with it.
-  set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
-  set(THREADS_HAVE_PTHREAD_ARG Off)
-  find_package(Threads REQUIRED)
-  set(LLVM_PTHREAD_LIB ${CMAKE_THREAD_LIBS_INIT})
-endif()
-
-if(LLVM_ENABLE_ZLIB)
-  if(LLVM_ENABLE_ZLIB STREQUAL FORCE_ON)
-    find_package(ZLIB REQUIRED)
-  elseif(NOT LLVM_USE_SANITIZER MATCHES "Memory.*")
-    find_package(ZLIB)
-  endif()
-  if(ZLIB_FOUND)
-    # Check if zlib we found is usable; for example, we may have found a 32-bit
-    # library on a 64-bit system which would result in a link-time failure.
-    cmake_push_check_state()
-    list(APPEND CMAKE_REQUIRED_INCLUDES ${ZLIB_INCLUDE_DIRS})
-    list(APPEND CMAKE_REQUIRED_LIBRARIES ${ZLIB_LIBRARY})
-    check_symbol_exists(compress2 zlib.h HAVE_ZLIB)
-    cmake_pop_check_state()
-    if(LLVM_ENABLE_ZLIB STREQUAL FORCE_ON AND NOT HAVE_ZLIB)
-      message(FATAL_ERROR "Failed to configure zlib")
-    endif()
-  endif()
-  set(LLVM_ENABLE_ZLIB "${HAVE_ZLIB}")
-endif()
-
-if(LLVM_ENABLE_LIBXML2)
-  if(LLVM_ENABLE_LIBXML2 STREQUAL FORCE_ON)
-    find_package(LibXml2 REQUIRED)
-  elseif(NOT LLVM_USE_SANITIZER MATCHES "Memory.*")
-    find_package(LibXml2)
-  endif()
-  if(LibXml2_FOUND)
-    # Check if libxml2 we found is usable; for example, we may have found a 32-bit
-    # library on a 64-bit system which would result in a link-time failure.
-    cmake_push_check_state()
-    list(APPEND CMAKE_REQUIRED_INCLUDES ${LIBXML2_INCLUDE_DIRS})
-    list(APPEND CMAKE_REQUIRED_LIBRARIES ${LIBXML2_LIBRARIES})
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS ${LIBXML2_DEFINITIONS})
-    check_symbol_exists(xmlReadMemory libxml/xmlreader.h HAVE_LIBXML2)
-    cmake_pop_check_state()
-    if(LLVM_ENABLE_LIBXML2 STREQUAL FORCE_ON AND NOT HAVE_LIBXML2)
-      message(FATAL_ERROR "Failed to configure libxml2")
-    endif()
-  endif()
-  set(LLVM_ENABLE_LIBXML2 "${HAVE_LIBXML2}")
-endif()
-
-if(LLVM_ENABLE_CURL)
-  if(LLVM_ENABLE_CURL STREQUAL FORCE_ON)
-    find_package(CURL REQUIRED)
-  else()
-    find_package(CURL)
-  endif()
-  if(CURL_FOUND)
-    # Check if curl we found is usable; for example, we may have found a 32-bit
-    # library on a 64-bit system which would result in a link-time failure.
-    cmake_push_check_state()
-    list(APPEND CMAKE_REQUIRED_INCLUDES ${CURL_INCLUDE_DIRS})
-    list(APPEND CMAKE_REQUIRED_LIBRARIES ${CURL_LIBRARY})
-    check_symbol_exists(curl_easy_init curl/curl.h HAVE_CURL)
-    cmake_pop_check_state()
-    if(LLVM_ENABLE_CURL STREQUAL FORCE_ON AND NOT HAVE_CURL)
-      message(FATAL_ERROR "Failed to configure curl")
-    endif()
-  endif()
-  set(LLVM_ENABLE_CURL "${HAVE_CURL}")
-endif()
-
-# Don't look for these libraries if we're using MSan, since uninstrumented third
-# party code may call MSan interceptors like strlen, leading to false positives.
-if(NOT LLVM_USE_SANITIZER MATCHES "Memory.*")
-  # Don't look for these libraries on Windows.
-  if (NOT PURE_WINDOWS)
-    # Skip libedit if using ASan as it contains memory leaks.
-    if (LLVM_ENABLE_LIBEDIT AND HAVE_HISTEDIT_H AND NOT LLVM_USE_SANITIZER MATCHES ".*Address.*")
-      check_library_exists(edit el_init "" HAVE_LIBEDIT)
-    else()
-      set(HAVE_LIBEDIT 0)
-    endif()
-    if(LLVM_ENABLE_TERMINFO)
-      if(LLVM_ENABLE_TERMINFO STREQUAL FORCE_ON)
-        find_package(Terminfo REQUIRED)
-      else()
-        find_package(Terminfo)
-      endif()
-      set(LLVM_ENABLE_TERMINFO "${Terminfo_FOUND}")
-    endif()
-  else()
-    set(LLVM_ENABLE_TERMINFO 0)
-  endif()
-else()
-  set(LLVM_ENABLE_TERMINFO 0)
-endif()
-
-check_library_exists(xar xar_open "" LLVM_HAVE_LIBXAR)
-if(LLVM_HAVE_LIBXAR)
-  message(STATUS "The xar file format has been deprecated: LLVM_HAVE_LIBXAR might be removed in the future.")
-  # The xar file format has been deprecated since macOS 12.0.
-  if (CMAKE_OSX_DEPLOYMENT_TARGET VERSION_GREATER_EQUAL 12)
-    set(LLVM_HAVE_LIBXAR 0)
-  else()
-    set(XAR_LIB xar)
-  endif()
-endif()
-
-# function checks
-check_symbol_exists(arc4random "stdlib.h" HAVE_DECL_ARC4RANDOM)
-find_package(Backtrace)
-set(HAVE_BACKTRACE ${Backtrace_FOUND})
-set(BACKTRACE_HEADER ${Backtrace_HEADER})
-
-# Prevent check_symbol_exists from using API that is not supported for a given
-# deployment target.
-check_c_compiler_flag("-Werror=unguarded-availability-new" "C_SUPPORTS_WERROR_UNGUARDED_AVAILABILITY_NEW")
-if(C_SUPPORTS_WERROR_UNGUARDED_AVAILABILITY_NEW)
-  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -Werror=unguarded-availability-new")
-endif()
-
-# Determine whether we can register EH tables.
-check_symbol_exists(__register_frame "${CMAKE_CURRENT_LIST_DIR}/unwind.h" HAVE_REGISTER_FRAME)
-check_symbol_exists(__deregister_frame "${CMAKE_CURRENT_LIST_DIR}/unwind.h" HAVE_DEREGISTER_FRAME)
-check_symbol_exists(__unw_add_dynamic_fde "${CMAKE_CURRENT_LIST_DIR}/unwind.h" HAVE_UNW_ADD_DYNAMIC_FDE)
-
-check_symbol_exists(_Unwind_Backtrace "unwind.h" HAVE__UNWIND_BACKTRACE)
-check_symbol_exists(getpagesize unistd.h HAVE_GETPAGESIZE)
-check_symbol_exists(sysconf unistd.h HAVE_SYSCONF)
-check_symbol_exists(getrusage sys/resource.h HAVE_GETRUSAGE)
-check_symbol_exists(setrlimit sys/resource.h HAVE_SETRLIMIT)
-check_symbol_exists(isatty unistd.h HAVE_ISATTY)
-check_symbol_exists(futimens sys/stat.h HAVE_FUTIMENS)
-check_symbol_exists(futimes sys/time.h HAVE_FUTIMES)
-# AddressSanitizer conflicts with lib/Support/Unix/Signals.inc
-# Avoid sigaltstack on Apple platforms, where backtrace() cannot handle it
-# (rdar://7089625) and _Unwind_Backtrace is unusable because it cannot unwind
-# past the signal handler after an assertion failure (rdar://29866587).
-if( HAVE_SIGNAL_H AND NOT LLVM_USE_SANITIZER MATCHES ".*Address.*" AND NOT APPLE )
-  check_symbol_exists(sigaltstack signal.h HAVE_SIGALTSTACK)
-endif()
-set(CMAKE_REQUIRED_DEFINITIONS "-D_LARGEFILE64_SOURCE")
-check_symbol_exists(lseek64 "sys/types.h;unistd.h" HAVE_LSEEK64)
-set(CMAKE_REQUIRED_DEFINITIONS "")
-check_symbol_exists(mallctl malloc_np.h HAVE_MALLCTL)
-check_symbol_exists(mallinfo malloc.h HAVE_MALLINFO)
-check_symbol_exists(mallinfo2 malloc.h HAVE_MALLINFO2)
-check_symbol_exists(malloc_zone_statistics malloc/malloc.h
-                    HAVE_MALLOC_ZONE_STATISTICS)
-check_symbol_exists(getrlimit "sys/types.h;sys/time.h;sys/resource.h" HAVE_GETRLIMIT)
-check_symbol_exists(posix_spawn spawn.h HAVE_POSIX_SPAWN)
-check_symbol_exists(pread unistd.h HAVE_PREAD)
-check_symbol_exists(sbrk unistd.h HAVE_SBRK)
-check_symbol_exists(strerror string.h HAVE_STRERROR)
-check_symbol_exists(strerror_r string.h HAVE_STRERROR_R)
-check_symbol_exists(strerror_s string.h HAVE_DECL_STRERROR_S)
-check_symbol_exists(setenv stdlib.h HAVE_SETENV)
-if( PURE_WINDOWS )
-  check_symbol_exists(_chsize_s io.h HAVE__CHSIZE_S)
-
-  check_function_exists(_alloca HAVE__ALLOCA)
-  check_function_exists(__alloca HAVE___ALLOCA)
-  check_function_exists(__chkstk HAVE___CHKSTK)
-  check_function_exists(__chkstk_ms HAVE___CHKSTK_MS)
-  check_function_exists(___chkstk HAVE____CHKSTK)
-  check_function_exists(___chkstk_ms HAVE____CHKSTK_MS)
-
-  check_function_exists(__ashldi3 HAVE___ASHLDI3)
-  check_function_exists(__ashrdi3 HAVE___ASHRDI3)
-  check_function_exists(__divdi3 HAVE___DIVDI3)
-  check_function_exists(__fixdfdi HAVE___FIXDFDI)
-  check_function_exists(__fixsfdi HAVE___FIXSFDI)
-  check_function_exists(__floatdidf HAVE___FLOATDIDF)
-  check_function_exists(__lshrdi3 HAVE___LSHRDI3)
-  check_function_exists(__moddi3 HAVE___MODDI3)
-  check_function_exists(__udivdi3 HAVE___UDIVDI3)
-  check_function_exists(__umoddi3 HAVE___UMODDI3)
-
-  check_function_exists(__main HAVE___MAIN)
-  check_function_exists(__cmpdi2 HAVE___CMPDI2)
-endif()
-if( HAVE_DLFCN_H )
-  if( HAVE_LIBDL )
-    list(APPEND CMAKE_REQUIRED_LIBRARIES dl)
-  endif()
-  check_symbol_exists(dlopen dlfcn.h HAVE_DLOPEN)
-  check_symbol_exists(dladdr dlfcn.h HAVE_DLADDR)
-  if( HAVE_LIBDL )
-    list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl)
-  endif()
-endif()
-
-CHECK_STRUCT_HAS_MEMBER("struct stat" st_mtimespec.tv_nsec
-    "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC)
-if (UNIX AND ${CMAKE_SYSTEM_NAME} MATCHES "AIX")
-# The st_mtim.tv_nsec member of a `stat` structure is not reliable on some AIX
-# environments.
-  set(HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0)
-else()
-  CHECK_STRUCT_HAS_MEMBER("struct stat" st_mtim.tv_nsec
-      "sys/types.h;sys/stat.h" HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
-endif()
-
-check_symbol_exists(__GLIBC__ stdio.h LLVM_USING_GLIBC)
-if( LLVM_USING_GLIBC )
-  add_definitions( -D_GNU_SOURCE )
-  list(APPEND CMAKE_REQUIRED_DEFINITIONS "-D_GNU_SOURCE")
-endif()
-# This check requires _GNU_SOURCE
-if (NOT PURE_WINDOWS)
-  if (LLVM_PTHREAD_LIB)
-    list(APPEND CMAKE_REQUIRED_LIBRARIES ${LLVM_PTHREAD_LIB})
-  endif()
-  check_symbol_exists(pthread_getname_np pthread.h HAVE_PTHREAD_GETNAME_NP)
-  check_symbol_exists(pthread_setname_np pthread.h HAVE_PTHREAD_SETNAME_NP)
-  if (LLVM_PTHREAD_LIB)
-    list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES ${LLVM_PTHREAD_LIB})
-  endif()
-endif()
-
-# available programs checks
-function(llvm_find_program name)
-  string(TOUPPER ${name} NAME)
-  string(REGEX REPLACE "\\." "_" NAME ${NAME})
-
-  find_program(LLVM_PATH_${NAME} NAMES ${ARGV})
-  mark_as_advanced(LLVM_PATH_${NAME})
-  if(LLVM_PATH_${NAME})
-    set(HAVE_${NAME} 1 CACHE INTERNAL "Is ${name} available ?")
-    mark_as_advanced(HAVE_${NAME})
-  else(LLVM_PATH_${NAME})
-    set(HAVE_${NAME} "" CACHE INTERNAL "Is ${name} available ?")
-  endif(LLVM_PATH_${NAME})
-endfunction()
-
-if (LLVM_ENABLE_DOXYGEN)
-  llvm_find_program(dot)
-endif ()
-
-if(LLVM_ENABLE_FFI)
-  set(FFI_REQUIRE_INCLUDE On)
-  if(LLVM_ENABLE_FFI STREQUAL FORCE_ON)
-    find_package(FFI REQUIRED)
-  else()
-    find_package(FFI)
-  endif()
-  set(LLVM_ENABLE_FFI "${FFI_FOUND}")
-else()
-  unset(HAVE_FFI_FFI_H CACHE)
-  unset(HAVE_FFI_H CACHE)
-  unset(HAVE_FFI_CALL CACHE)
-endif()
-
-check_symbol_exists(proc_pid_rusage "libproc.h" HAVE_PROC_PID_RUSAGE)
-
-# Whether we can use std::is_trivially_copyable to verify llvm::is_trivially_copyable.
-CHECK_CXX_SOURCE_COMPILES("
-#include <type_traits>
-struct T { int val; };
-static_assert(std::is_trivially_copyable<T>::value, \"ok\");
-int main() { return 0;}
-" HAVE_STD_IS_TRIVIALLY_COPYABLE)
-
-
-# Define LLVM_HAS_ATOMICS if gcc or MSVC atomic builtins are supported.
-include(CheckAtomic)
-
-if( LLVM_ENABLE_PIC )
-  set(ENABLE_PIC 1)
-else()
-  set(ENABLE_PIC 0)
-  check_cxx_compiler_flag("-fno-pie" SUPPORTS_NO_PIE_FLAG)
-  if(SUPPORTS_NO_PIE_FLAG)
-    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fno-pie")
-  endif()
-endif()
-
-check_cxx_compiler_flag("-Wvariadic-macros" SUPPORTS_VARIADIC_MACROS_FLAG)
-check_cxx_compiler_flag("-Wgnu-zero-variadic-macro-arguments"
-                        SUPPORTS_GNU_ZERO_VARIADIC_MACRO_ARGUMENTS_FLAG)
-
-set(USE_NO_MAYBE_UNINITIALIZED 0)
-set(USE_NO_UNINITIALIZED 0)
-
-# Disable gcc's potentially uninitialized use analysis as it presents lots of
-# false positives.
-if (CMAKE_COMPILER_IS_GNUCXX)
-  check_cxx_compiler_flag("-Wmaybe-uninitialized" HAS_MAYBE_UNINITIALIZED)
-  if (HAS_MAYBE_UNINITIALIZED)
-    set(USE_NO_MAYBE_UNINITIALIZED 1)
-  else()
-    # Only recent versions of gcc make the distinction between -Wuninitialized
-    # and -Wmaybe-uninitialized. If -Wmaybe-uninitialized isn't supported, just
-    # turn off all uninitialized use warnings.
-    check_cxx_compiler_flag("-Wuninitialized" HAS_UNINITIALIZED)
-    set(USE_NO_UNINITIALIZED ${HAS_UNINITIALIZED})
-  endif()
-endif()
-
-# By default, we target the host, but this can be overridden at CMake
-# invocation time.
-include(GetHostTriple)
-get_host_triple(LLVM_INFERRED_HOST_TRIPLE)
-
-set(LLVM_HOST_TRIPLE "${LLVM_INFERRED_HOST_TRIPLE}" CACHE STRING
-    "Host on which LLVM binaries will run")
-
-# Determine the native architecture.
-string(TOLOWER "${LLVM_TARGET_ARCH}" LLVM_NATIVE_ARCH)
-if( LLVM_NATIVE_ARCH STREQUAL "host" )
-  string(REGEX MATCH "^[^-]*" LLVM_NATIVE_ARCH ${LLVM_HOST_TRIPLE})
-endif ()
-
-if (LLVM_NATIVE_ARCH MATCHES "i[2-6]86")
-  set(LLVM_NATIVE_ARCH X86)
-elseif (LLVM_NATIVE_ARCH STREQUAL "x86")
-  set(LLVM_NATIVE_ARCH X86)
-elseif (LLVM_NATIVE_ARCH STREQUAL "amd64")
-  set(LLVM_NATIVE_ARCH X86)
-elseif (LLVM_NATIVE_ARCH STREQUAL "x86_64")
-  set(LLVM_NATIVE_ARCH X86)
-elseif (LLVM_NATIVE_ARCH MATCHES "sparc")
-  set(LLVM_NATIVE_ARCH Sparc)
-elseif (LLVM_NATIVE_ARCH MATCHES "powerpc")
-  set(LLVM_NATIVE_ARCH PowerPC)
-elseif (LLVM_NATIVE_ARCH MATCHES "ppc64le")
-  set(LLVM_NATIVE_ARCH PowerPC)
-elseif (LLVM_NATIVE_ARCH MATCHES "aarch64")
-  set(LLVM_NATIVE_ARCH AArch64)
-elseif (LLVM_NATIVE_ARCH MATCHES "arm64")
-  set(LLVM_NATIVE_ARCH AArch64)
-elseif (LLVM_NATIVE_ARCH MATCHES "arm")
-  set(LLVM_NATIVE_ARCH ARM)
-elseif (LLVM_NATIVE_ARCH MATCHES "avr")
-  set(LLVM_NATIVE_ARCH AVR)
-elseif (LLVM_NATIVE_ARCH MATCHES "mips")
-  set(LLVM_NATIVE_ARCH Mips)
-elseif (LLVM_NATIVE_ARCH MATCHES "xcore")
-  set(LLVM_NATIVE_ARCH XCore)
-elseif (LLVM_NATIVE_ARCH MATCHES "msp430")
-  set(LLVM_NATIVE_ARCH MSP430)
-elseif (LLVM_NATIVE_ARCH MATCHES "hexagon")
-  set(LLVM_NATIVE_ARCH Hexagon)
-elseif (LLVM_NATIVE_ARCH MATCHES "s390x")
-  set(LLVM_NATIVE_ARCH SystemZ)
-elseif (LLVM_NATIVE_ARCH MATCHES "wasm32")
-  set(LLVM_NATIVE_ARCH WebAssembly)
-elseif (LLVM_NATIVE_ARCH MATCHES "wasm64")
-  set(LLVM_NATIVE_ARCH WebAssembly)
-elseif (LLVM_NATIVE_ARCH MATCHES "riscv32")
-  set(LLVM_NATIVE_ARCH RISCV)
-elseif (LLVM_NATIVE_ARCH MATCHES "riscv64")
-  set(LLVM_NATIVE_ARCH RISCV)
-elseif (LLVM_NATIVE_ARCH STREQUAL "m68k")
-  set(LLVM_NATIVE_ARCH M68k)
-else ()
-  message(FATAL_ERROR "Unknown architecture ${LLVM_NATIVE_ARCH}")
-endif ()
-
-# If build targets includes "host" or "Native", then replace with native architecture.
-foreach (NATIVE_KEYWORD host Native)
-  list(FIND LLVM_TARGETS_TO_BUILD ${NATIVE_KEYWORD} idx)
-  if( NOT idx LESS 0 )
-    list(REMOVE_AT LLVM_TARGETS_TO_BUILD ${idx})
-    list(APPEND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH})
-    list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD)
-  endif()
-endforeach()
-
-list(FIND LLVM_TARGETS_TO_BUILD ${LLVM_NATIVE_ARCH} NATIVE_ARCH_IDX)
-if (NATIVE_ARCH_IDX EQUAL -1)
-  message(STATUS
-    "Native target ${LLVM_NATIVE_ARCH} is not selected; lli will not JIT code")
-else ()
-  message(STATUS "Native target architecture is ${LLVM_NATIVE_ARCH}")
-  set(LLVM_NATIVE_TARGET LLVMInitialize${LLVM_NATIVE_ARCH}Target)
-  set(LLVM_NATIVE_TARGETINFO LLVMInitialize${LLVM_NATIVE_ARCH}TargetInfo)
-  set(LLVM_NATIVE_TARGETMC LLVMInitialize${LLVM_NATIVE_ARCH}TargetMC)
-  set(LLVM_NATIVE_ASMPRINTER LLVMInitialize${LLVM_NATIVE_ARCH}AsmPrinter)
-
-  # We don't have an ASM parser for all architectures yet.
-  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/AsmParser/CMakeLists.txt)
-    set(LLVM_NATIVE_ASMPARSER LLVMInitialize${LLVM_NATIVE_ARCH}AsmParser)
-  endif ()
-
-  # We don't have an disassembler for all architectures yet.
-  if (EXISTS ${PROJECT_SOURCE_DIR}/lib/Target/${LLVM_NATIVE_ARCH}/Disassembler/CMakeLists.txt)
-    set(LLVM_NATIVE_DISASSEMBLER LLVMInitialize${LLVM_NATIVE_ARCH}Disassembler)
-  endif ()
-endif ()
-
-if( MSVC )
-  set(SHLIBEXT ".lib")
-  set(stricmp "_stricmp")
-  set(strdup "_strdup")
-
-  # Allow setting clang-cl's /winsysroot flag.
-  set(LLVM_WINSYSROOT "" CACHE STRING
-    "If set, argument to clang-cl's /winsysroot")
-
-  if (LLVM_WINSYSROOT)
-    set(MSVC_DIA_SDK_DIR "${LLVM_WINSYSROOT}/DIA SDK" CACHE PATH
-        "Path to the DIA SDK")
-  else()
-    set(MSVC_DIA_SDK_DIR "$ENV{VSINSTALLDIR}DIA SDK" CACHE PATH
-        "Path to the DIA SDK")
-  endif()
-
-  # See if the DIA SDK is available and usable.
-  # Due to a bug in MSVC 2013's installation software, it is possible
-  # for MSVC 2013 to write the DIA SDK into the Visual Studio 2012
-  # install directory.  If this happens, the installation is corrupt
-  # and there's nothing we can do.  It happens with enough frequency
-  # though that we should handle it.  We do so by simply checking that
-  # the DIA SDK folder exists.  Should this happen you will need to
-  # uninstall VS 2012 and then re-install VS 2013.
-  if (IS_DIRECTORY "${MSVC_DIA_SDK_DIR}")
-    set(HAVE_DIA_SDK 1)
-  else()
-    set(HAVE_DIA_SDK 0)
-  endif()
-
-  option(LLVM_ENABLE_DIA_SDK "Use MSVC DIA SDK for debugging if available."
-                             ${HAVE_DIA_SDK})
-
-  if(LLVM_ENABLE_DIA_SDK AND NOT HAVE_DIA_SDK)
-    message(FATAL_ERROR "DIA SDK not found. If you have both VS 2012 and 2013 installed, you may need to uninstall the former and re-install the latter afterwards.")
-  endif()
-else()
-  set(LLVM_ENABLE_DIA_SDK 0)
-endif( MSVC )
-
-# FIXME: Signal handler return type, currently hardcoded to 'void'
-set(RETSIGTYPE void)
-
-if( LLVM_ENABLE_THREADS )
-  # Check if threading primitives aren't supported on this platform
-  if( NOT HAVE_PTHREAD_H AND NOT WIN32 )
-    set(LLVM_ENABLE_THREADS 0)
-  endif()
-endif()
-
-if( LLVM_ENABLE_THREADS )
-  message(STATUS "Threads enabled.")
-else( LLVM_ENABLE_THREADS )
-  message(STATUS "Threads disabled.")
-endif()
-
-if (LLVM_ENABLE_DOXYGEN)
-  message(STATUS "Doxygen enabled.")
-  find_package(Doxygen REQUIRED)
-
-  if (DOXYGEN_FOUND)
-    # If we find doxygen and we want to enable doxygen by default create a
-    # global aggregate doxygen target for generating llvm and any/all
-    # subprojects doxygen documentation.
-    if (LLVM_BUILD_DOCS)
-      add_custom_target(doxygen ALL)
-    endif()
-
-    option(LLVM_DOXYGEN_EXTERNAL_SEARCH "Enable doxygen external search." OFF)
-    if (LLVM_DOXYGEN_EXTERNAL_SEARCH)
-      set(LLVM_DOXYGEN_SEARCHENGINE_URL "" CACHE STRING "URL to use for external search.")
-      set(LLVM_DOXYGEN_SEARCH_MAPPINGS "" CACHE STRING "Doxygen Search Mappings")
-    endif()
-  endif()
-else()
-  message(STATUS "Doxygen disabled.")
-endif()
-
-set(LLVM_BINDINGS "")
-find_program(GO_EXECUTABLE NAMES go DOC "go executable")
-if(WIN32 OR NOT LLVM_ENABLE_BINDINGS)
-  message(STATUS "Go bindings disabled.")
-else()
-  if(GO_EXECUTABLE STREQUAL "GO_EXECUTABLE-NOTFOUND")
-    message(STATUS "Go bindings disabled.")
-  else()
-    execute_process(COMMAND ${GO_EXECUTABLE} run ${PROJECT_SOURCE_DIR}/bindings/go/conftest.go
-                    RESULT_VARIABLE GO_CONFTEST)
-    if(GO_CONFTEST STREQUAL "0")
-      set(LLVM_BINDINGS "${LLVM_BINDINGS} go")
-      message(STATUS "Go bindings enabled.")
-    else()
-      message(STATUS "Go bindings disabled, need at least Go 1.2.")
-    endif()
-  endif()
-endif()
-
-find_program(GOLD_EXECUTABLE NAMES ${LLVM_DEFAULT_TARGET_TRIPLE}-ld.gold ld.gold ${LLVM_DEFAULT_TARGET_TRIPLE}-ld ld DOC "The gold linker")
-set(LLVM_BINUTILS_INCDIR "" CACHE PATH
-    "PATH to binutils/include containing plugin-api.h for gold plugin.")
-
-if(CMAKE_GENERATOR MATCHES "Ninja")
-  execute_process(COMMAND ${CMAKE_MAKE_PROGRAM} --version
-    OUTPUT_VARIABLE NINJA_VERSION
-    OUTPUT_STRIP_TRAILING_WHITESPACE)
-  set(NINJA_VERSION ${NINJA_VERSION} CACHE STRING "Ninja version number" FORCE)
-  message(STATUS "Ninja version: ${NINJA_VERSION}")
-endif()
-
-if(CMAKE_GENERATOR MATCHES "Ninja" AND
-    NOT "${NINJA_VERSION}" VERSION_LESS "1.9.0" AND
-    CMAKE_HOST_APPLE AND CMAKE_HOST_SYSTEM_VERSION VERSION_GREATER "15.6.0")
-  set(LLVM_TOUCH_STATIC_LIBRARIES ON)
-endif()
-
-if(CMAKE_HOST_APPLE AND APPLE)
-  if(NOT CMAKE_XCRUN)
-    find_program(CMAKE_XCRUN NAMES xcrun)
-  endif()
-  if(CMAKE_XCRUN)
-    execute_process(COMMAND ${CMAKE_XCRUN} -find ld
-      OUTPUT_VARIABLE LD64_EXECUTABLE
-      OUTPUT_STRIP_TRAILING_WHITESPACE)
-  else()
-    find_program(LD64_EXECUTABLE NAMES ld DOC "The ld64 linker")
-  endif()
-
-  if(LD64_EXECUTABLE)
-    set(LD64_EXECUTABLE ${LD64_EXECUTABLE} CACHE PATH "ld64 executable")
-    message(STATUS "Found ld64 - ${LD64_EXECUTABLE}")
-  endif()
-endif()
-
-# Keep the version requirements in sync with bindings/ocaml/README.txt.
-include(FindOCaml)
-include(AddOCaml)
-if(WIN32 OR NOT LLVM_ENABLE_BINDINGS)
-  message(STATUS "OCaml bindings disabled.")
-else()
-  find_package(OCaml)
-  if( NOT OCAML_FOUND )
-    message(STATUS "OCaml bindings disabled.")
-  else()
-    if( OCAML_VERSION VERSION_LESS "4.00.0" )
-      message(STATUS "OCaml bindings disabled, need OCaml >=4.00.0.")
-    else()
-      find_ocamlfind_package(ctypes VERSION 0.4 OPTIONAL)
-      if( HAVE_OCAML_CTYPES )
-        message(STATUS "OCaml bindings enabled.")
-        set(LLVM_BINDINGS "${LLVM_BINDINGS} ocaml")
-
-        set(LLVM_OCAML_INSTALL_PATH "${OCAML_STDLIB_PATH}" CACHE STRING
-            "Install directory for LLVM OCaml packages")
-      else()
-        message(STATUS "OCaml bindings disabled, need ctypes >=0.4.")
-      endif()
-    endif()
-  endif()
-endif()
-
-string(REPLACE " " ";" LLVM_BINDINGS_LIST "${LLVM_BINDINGS}")
-
-function(find_python_module module)
-  string(REPLACE "." "_" module_name ${module})
-  string(TOUPPER ${module_name} module_upper)
-  set(FOUND_VAR PY_${module_upper}_FOUND)
-  if (DEFINED ${FOUND_VAR})
-    return()
-  endif()
-
-  execute_process(COMMAND "${Python3_EXECUTABLE}" "-c" "import ${module}"
-    RESULT_VARIABLE status
-    ERROR_QUIET)
-
-  if(status)
-    set(${FOUND_VAR} OFF CACHE BOOL "Failed to find python module '${module}'")
-    message(STATUS "Could NOT find Python module ${module}")
-  else()
-  set(${FOUND_VAR} ON CACHE BOOL "Found python module '${module}'")
-    message(STATUS "Found Python module ${module}")
-  endif()
-endfunction()
-
-set (PYTHON_MODULES
-  pygments
-  # Some systems still don't have pygments.lexers.c_cpp which was introduced in
-  # version 2.0 in 2014...
-  pygments.lexers.c_cpp
-  yaml
-  )
-foreach(module ${PYTHON_MODULES})
-  find_python_module(${module})
-endforeach()
-
-if(PY_PYGMENTS_FOUND AND PY_PYGMENTS_LEXERS_C_CPP_FOUND AND PY_YAML_FOUND)
-  set (LLVM_HAVE_OPT_VIEWER_MODULES 1)
-else()
-  set (LLVM_HAVE_OPT_VIEWER_MODULES 0)
-endif()
-
-function(llvm_get_host_prefixes_and_suffixes)
-  # Not all platform files will set these variables (relying on them being
-  # implicitly empty if they're unset), so unset the variables before including
-  # the platform file, to prevent any values from the target system leaking.
-  unset(CMAKE_STATIC_LIBRARY_PREFIX)
-  unset(CMAKE_STATIC_LIBRARY_SUFFIX)
-  unset(CMAKE_SHARED_LIBRARY_PREFIX)
-  unset(CMAKE_SHARED_LIBRARY_SUFFIX)
-  unset(CMAKE_IMPORT_LIBRARY_PREFIX)
-  unset(CMAKE_IMPORT_LIBRARY_SUFFIX)
-  unset(CMAKE_EXECUTABLE_SUFFIX)
-  unset(CMAKE_LINK_LIBRARY_SUFFIX)
-  include(Platform/${CMAKE_HOST_SYSTEM_NAME} OPTIONAL RESULT_VARIABLE _includedFile)
-  if (_includedFile)
-    set(LLVM_HOST_STATIC_LIBRARY_PREFIX ${CMAKE_STATIC_LIBRARY_PREFIX} PARENT_SCOPE)
-    set(LLVM_HOST_STATIC_LIBRARY_SUFFIX ${CMAKE_STATIC_LIBRARY_SUFFIX} PARENT_SCOPE)
-    set(LLVM_HOST_SHARED_LIBRARY_PREFIX ${CMAKE_SHARED_LIBRARY_PREFIX} PARENT_SCOPE)
-    set(LLVM_HOST_SHARED_LIBRARY_SUFFIX ${CMAKE_SHARED_LIBRARY_SUFFIX} PARENT_SCOPE)
-    set(LLVM_HOST_IMPORT_LIBRARY_PREFIX ${CMAKE_IMPORT_LIBRARY_PREFIX} PARENT_SCOPE)
-    set(LLVM_HOST_IMPORT_LIBRARY_SUFFIX ${CMAKE_IMPORT_LIBRARY_SUFFIX} PARENT_SCOPE)
-    set(LLVM_HOST_EXECUTABLE_SUFFIX ${CMAKE_EXECUTABLE_SUFFIX} PARENT_SCOPE)
-    set(LLVM_HOST_LINK_LIBRARY_SUFFIX ${CMAKE_LINK_LIBRARY_SUFFIX} PARENT_SCOPE)
-  endif()
-endfunction()
-
-llvm_get_host_prefixes_and_suffixes()
diff --git a/llvm/cmake/config-ix.cmake b/llvm/cmake/config-ix.cmake
new file mode 120000
index 000000000000..465a6417f806
--- /dev/null
+++ b/llvm/cmake/config-ix.cmake
@@ -0,0 +1 @@
+/home/ormastes/dev/pri/toy-riscv-backend/llvm/cmake/config-ix.cmake
\ No newline at end of file
diff --git a/llvm/include/llvm/ADT/Triple.h b/llvm/include/llvm/ADT/Triple.h
deleted file mode 100644
index 42277c013035..000000000000
--- a/llvm/include/llvm/ADT/Triple.h
+++ /dev/null
@@ -1,1005 +0,0 @@
-//===-- llvm/ADT/Triple.h - Target triple helper class ----------*- C++ -*-===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_ADT_TRIPLE_H
-#define LLVM_ADT_TRIPLE_H
-
-#include "llvm/ADT/Twine.h"
-#include "llvm/Support/VersionTuple.h"
-
-// Some system headers or GCC predefined macros conflict with identifiers in
-// this file.  Undefine them here.
-#undef NetBSD
-#undef mips
-#undef sparc
-
-namespace llvm {
-
-/// Triple - Helper class for working with autoconf configuration names. For
-/// historical reasons, we also call these 'triples' (they used to contain
-/// exactly three fields).
-///
-/// Configuration names are strings in the canonical form:
-///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM
-/// or
-///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
-///
-/// This class is used for clients which want to support arbitrary
-/// configuration names, but also want to implement certain special
-/// behavior for particular configurations. This class isolates the mapping
-/// from the components of the configuration name to well known IDs.
-///
-/// At its core the Triple class is designed to be a wrapper for a triple
-/// string; the constructor does not change or normalize the triple string.
-/// Clients that need to handle the non-canonical triples that users often
-/// specify should use the normalize method.
-///
-/// See autoconf/config.guess for a glimpse into what configuration names
-/// look like in practice.
-class Triple {
-public:
-  enum ArchType {
-    UnknownArch,
-
-    arm,            // ARM (little endian): arm, armv.*, xscale
-    armeb,          // ARM (big endian): armeb
-    aarch64,        // AArch64 (little endian): aarch64
-    aarch64_be,     // AArch64 (big endian): aarch64_be
-    aarch64_32,     // AArch64 (little endian) ILP32: aarch64_32
-    arc,            // ARC: Synopsys ARC
-    avr,            // AVR: Atmel AVR microcontroller
-    bpfel,          // eBPF or extended BPF or 64-bit BPF (little endian)
-    bpfeb,          // eBPF or extended BPF or 64-bit BPF (big endian)
-    csky,           // CSKY: csky
-    hexagon,        // Hexagon: hexagon
-    m68k,           // M68k: Motorola 680x0 family
-    mips,           // MIPS: mips, mipsallegrex, mipsr6
-    mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el
-    mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6
-    mips64el,       // MIPS64EL: mips64el, mips64r6el, mipsn32el, mipsn32r6el
-    msp430,         // MSP430: msp430
-    ppc,            // PPC: powerpc
-    ppcle,          // PPCLE: powerpc (little endian)
-    ppc64,          // PPC64: powerpc64, ppu
-    ppc64le,        // PPC64LE: powerpc64le
-    r600,           // R600: AMD GPUs HD2XXX - HD6XXX
-    amdgcn,         // AMDGCN: AMD GCN GPUs
-    riscv32,        // RISC-V (32-bit): riscv32
-    riscv64,        // RISC-V (64-bit): riscv64
-    sparc,          // Sparc: sparc
-    sparcv9,        // Sparcv9: Sparcv9
-    sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant
-    systemz,        // SystemZ: s390x
-    tce,            // TCE (http://tce.cs.tut.fi/): tce
-    tcele,          // TCE little endian (http://tce.cs.tut.fi/): tcele
-    thumb,          // Thumb (little endian): thumb, thumbv.*
-    thumbeb,        // Thumb (big endian): thumbeb
-    x86,            // X86: i[3-9]86
-    x86_64,         // X86-64: amd64, x86_64
-    xcore,          // XCore: xcore
-    nvptx,          // NVPTX: 32-bit
-    nvptx64,        // NVPTX: 64-bit
-    le32,           // le32: generic little-endian 32-bit CPU (PNaCl)
-    le64,           // le64: generic little-endian 64-bit CPU (PNaCl)
-    amdil,          // AMDIL
-    amdil64,        // AMDIL with 64-bit pointers
-    hsail,          // AMD HSAIL
-    hsail64,        // AMD HSAIL with 64-bit pointers
-    spir,           // SPIR: standard portable IR for OpenCL 32-bit version
-    spir64,         // SPIR: standard portable IR for OpenCL 64-bit version
-    spirv32,        // SPIR-V with 32-bit pointers
-    spirv64,        // SPIR-V with 64-bit pointers
-    kalimba,        // Kalimba: generic kalimba
-    shave,          // SHAVE: Movidius vector VLIW processors
-    lanai,          // Lanai: Lanai 32-bit
-    wasm32,         // WebAssembly with 32-bit pointers
-    wasm64,         // WebAssembly with 64-bit pointers
-    renderscript32, // 32-bit RenderScript
-    renderscript64, // 64-bit RenderScript
-    ve,             // NEC SX-Aurora Vector Engine
-    LastArchType = ve
-  };
-  enum SubArchType {
-    NoSubArch,
-
-    ARMSubArch_v9_3a,
-    ARMSubArch_v9_2a,
-    ARMSubArch_v9_1a,
-    ARMSubArch_v9,
-    ARMSubArch_v8_8a,
-    ARMSubArch_v8_7a,
-    ARMSubArch_v8_6a,
-    ARMSubArch_v8_5a,
-    ARMSubArch_v8_4a,
-    ARMSubArch_v8_3a,
-    ARMSubArch_v8_2a,
-    ARMSubArch_v8_1a,
-    ARMSubArch_v8,
-    ARMSubArch_v8r,
-    ARMSubArch_v8m_baseline,
-    ARMSubArch_v8m_mainline,
-    ARMSubArch_v8_1m_mainline,
-    ARMSubArch_v7,
-    ARMSubArch_v7em,
-    ARMSubArch_v7m,
-    ARMSubArch_v7s,
-    ARMSubArch_v7k,
-    ARMSubArch_v7ve,
-    ARMSubArch_v6,
-    ARMSubArch_v6m,
-    ARMSubArch_v6k,
-    ARMSubArch_v6t2,
-    ARMSubArch_v5,
-    ARMSubArch_v5te,
-    ARMSubArch_v4t,
-
-    AArch64SubArch_arm64e,
-
-    KalimbaSubArch_v3,
-    KalimbaSubArch_v4,
-    KalimbaSubArch_v5,
-
-    MipsSubArch_r6,
-
-    PPCSubArch_spe
-  };
-  enum VendorType {
-    UnknownVendor,
-
-    Apple,
-    PC,
-    SCEI,
-    Freescale,
-    IBM,
-    ImaginationTechnologies,
-    MipsTechnologies,
-    NVIDIA,
-    CSR,
-    Myriad,
-    AMD,
-    Mesa,
-    SUSE,
-    OpenEmbedded,
-    LastVendorType = OpenEmbedded
-  };
-  enum OSType {
-    UnknownOS,
-
-    Ananas,
-    CloudABI,
-    Darwin,
-    DragonFly,
-    FreeBSD,
-    Fuchsia,
-    IOS,
-    KFreeBSD,
-    Linux,
-    Lv2,        // PS3
-    MacOSX,
-    NetBSD,
-    OpenBSD,
-    Solaris,
-    Win32,
-    ZOS,
-    Haiku,
-    Minix,
-    RTEMS,
-    NaCl,       // Native Client
-    AIX,
-    CUDA,       // NVIDIA CUDA
-    NVCL,       // NVIDIA OpenCL
-    AMDHSA,     // AMD HSA Runtime
-    PS4,
-    ELFIAMCU,
-    TvOS,       // Apple tvOS
-    WatchOS,    // Apple watchOS
-    Mesa3D,
-    Contiki,
-    AMDPAL,     // AMD PAL Runtime
-    HermitCore, // HermitCore Unikernel/Multikernel
-    Hurd,       // GNU/Hurd
-    WASI,       // Experimental WebAssembly OS
-    Emscripten,
-    LastOSType = Emscripten
-  };
-  enum EnvironmentType {
-    UnknownEnvironment,
-
-    GNU,
-    GNUABIN32,
-    GNUABI64,
-    GNUEABI,
-    GNUEABIHF,
-    GNUX32,
-    GNUILP32,
-    CODE16,
-    EABI,
-    EABIHF,
-    Android,
-    Musl,
-    MuslEABI,
-    MuslEABIHF,
-    MuslX32,
-
-    MSVC,
-    Itanium,
-    Cygnus,
-    CoreCLR,
-    Simulator, // Simulator variants of other systems, e.g., Apple's iOS
-    MacABI, // Mac Catalyst variant of Apple's iOS deployment target.
-    LastEnvironmentType = MacABI
-  };
-  enum ObjectFormatType {
-    UnknownObjectFormat,
-
-    COFF,
-    ELF,
-    GOFF,
-    MachO,
-    Wasm,
-    XCOFF,
-  };
-
-private:
-  std::string Data;
-
-  /// The parsed arch type.
-  ArchType Arch;
-
-  /// The parsed subarchitecture type.
-  SubArchType SubArch;
-
-  /// The parsed vendor type.
-  VendorType Vendor;
-
-  /// The parsed OS type.
-  OSType OS;
-
-  /// The parsed Environment type.
-  EnvironmentType Environment;
-
-  /// The object format type.
-  ObjectFormatType ObjectFormat;
-
-public:
-  /// @name Constructors
-  /// @{
-
-  /// Default constructor is the same as an empty string and leaves all
-  /// triple fields unknown.
-  Triple() : Arch(), SubArch(), Vendor(), OS(), Environment(), ObjectFormat() {}
-
-  explicit Triple(const Twine &Str);
-  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr);
-  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr,
-         const Twine &EnvironmentStr);
-
-  bool operator==(const Triple &Other) const {
-    return Arch == Other.Arch && SubArch == Other.SubArch &&
-           Vendor == Other.Vendor && OS == Other.OS &&
-           Environment == Other.Environment &&
-           ObjectFormat == Other.ObjectFormat;
-  }
-
-  bool operator!=(const Triple &Other) const {
-    return !(*this == Other);
-  }
-
-  /// @}
-  /// @name Normalization
-  /// @{
-
-  /// Turn an arbitrary machine specification into the canonical triple form (or
-  /// something sensible that the Triple class understands if nothing better can
-  /// reasonably be done).  In particular, it handles the common case in which
-  /// otherwise valid components are in the wrong order.
-  static std::string normalize(StringRef Str);
-
-  /// Return the normalized form of this triple's string.
-  std::string normalize() const { return normalize(Data); }
-
-  /// @}
-  /// @name Typed Component Access
-  /// @{
-
-  /// Get the parsed architecture type of this triple.
-  ArchType getArch() const { return Arch; }
-
-  /// get the parsed subarchitecture type for this triple.
-  SubArchType getSubArch() const { return SubArch; }
-
-  /// Get the parsed vendor type of this triple.
-  VendorType getVendor() const { return Vendor; }
-
-  /// Get the parsed operating system type of this triple.
-  OSType getOS() const { return OS; }
-
-  /// Does this triple have the optional environment (fourth) component?
-  bool hasEnvironment() const {
-    return getEnvironmentName() != "";
-  }
-
-  /// Get the parsed environment type of this triple.
-  EnvironmentType getEnvironment() const { return Environment; }
-
-  /// Parse the version number from the OS name component of the
-  /// triple, if present.
-  ///
-  /// For example, "fooos1.2.3" would return (1, 2, 3).
-  VersionTuple getEnvironmentVersion() const;
-
-  /// Get the object format for this triple.
-  ObjectFormatType getObjectFormat() const { return ObjectFormat; }
-
-  /// Parse the version number from the OS name component of the triple, if
-  /// present.
-  ///
-  /// For example, "fooos1.2.3" would return (1, 2, 3).
-  VersionTuple getOSVersion() const;
-
-  /// Return just the major version number, this is specialized because it is a
-  /// common query.
-  unsigned getOSMajorVersion() const { return getOSVersion().getMajor(); }
-
-  /// Parse the version number as with getOSVersion and then translate generic
-  /// "darwin" versions to the corresponding OS X versions.  This may also be
-  /// called with IOS triples but the OS X version number is just set to a
-  /// constant 10.4.0 in that case.  Returns true if successful.
-  bool getMacOSXVersion(VersionTuple &Version) const;
-
-  /// Parse the version number as with getOSVersion.  This should only be called
-  /// with IOS or generic triples.
-  VersionTuple getiOSVersion() const;
-
-  /// Parse the version number as with getOSVersion.  This should only be called
-  /// with WatchOS or generic triples.
-  VersionTuple getWatchOSVersion() const;
-
-  /// @}
-  /// @name Direct Component Access
-  /// @{
-
-  const std::string &str() const { return Data; }
-
-  const std::string &getTriple() const { return Data; }
-
-  /// Get the architecture (first) component of the triple.
-  StringRef getArchName() const;
-
-  /// Get the architecture name based on Kind and SubArch.
-  StringRef getArchName(ArchType Kind, SubArchType SubArch = NoSubArch) const;
-
-  /// Get the vendor (second) component of the triple.
-  StringRef getVendorName() const;
-
-  /// Get the operating system (third) component of the triple.
-  StringRef getOSName() const;
-
-  /// Get the optional environment (fourth) component of the triple, or "" if
-  /// empty.
-  StringRef getEnvironmentName() const;
-
-  /// Get the operating system and optional environment components as a single
-  /// string (separated by a '-' if the environment component is present).
-  StringRef getOSAndEnvironmentName() const;
-
-  /// @}
-  /// @name Convenience Predicates
-  /// @{
-
-  /// Test whether the architecture is 64-bit
-  ///
-  /// Note that this tests for 64-bit pointer width, and nothing else. Note
-  /// that we intentionally expose only three predicates, 64-bit, 32-bit, and
-  /// 16-bit. The inner details of pointer width for particular architectures
-  /// is not summed up in the triple, and so only a coarse grained predicate
-  /// system is provided.
-  bool isArch64Bit() const;
-
-  /// Test whether the architecture is 32-bit
-  ///
-  /// Note that this tests for 32-bit pointer width, and nothing else.
-  bool isArch32Bit() const;
-
-  /// Test whether the architecture is 16-bit
-  ///
-  /// Note that this tests for 16-bit pointer width, and nothing else.
-  bool isArch16Bit() const;
-
-  /// Helper function for doing comparisons against version numbers included in
-  /// the target triple.
-  bool isOSVersionLT(unsigned Major, unsigned Minor = 0,
-                     unsigned Micro = 0) const {
-    if (Minor == 0) {
-      return getOSVersion() < VersionTuple(Major);
-    }
-    if (Micro == 0) {
-      return getOSVersion() < VersionTuple(Major, Minor);
-    }
-    return getOSVersion() < VersionTuple(Major, Minor, Micro);
-  }
-
-  bool isOSVersionLT(const Triple &Other) const {
-    return getOSVersion() < Other.getOSVersion();
-  }
-
-  /// Comparison function for checking OS X version compatibility, which handles
-  /// supporting skewed version numbering schemes used by the "darwin" triples.
-  bool isMacOSXVersionLT(unsigned Major, unsigned Minor = 0,
-                         unsigned Micro = 0) const;
-
-  /// Is this a Mac OS X triple. For legacy reasons, we support both "darwin"
-  /// and "osx" as OS X triples.
-  bool isMacOSX() const {
-    return getOS() == Triple::Darwin || getOS() == Triple::MacOSX;
-  }
-
-  /// Is this an iOS triple.
-  /// Note: This identifies tvOS as a variant of iOS. If that ever
-  /// changes, i.e., if the two operating systems diverge or their version
-  /// numbers get out of sync, that will need to be changed.
-  /// watchOS has completely different version numbers so it is not included.
-  bool isiOS() const {
-    return getOS() == Triple::IOS || isTvOS();
-  }
-
-  /// Is this an Apple tvOS triple.
-  bool isTvOS() const {
-    return getOS() == Triple::TvOS;
-  }
-
-  /// Is this an Apple watchOS triple.
-  bool isWatchOS() const {
-    return getOS() == Triple::WatchOS;
-  }
-
-  bool isWatchABI() const {
-    return getSubArch() == Triple::ARMSubArch_v7k;
-  }
-
-  bool isOSzOS() const { return getOS() == Triple::ZOS; }
-
-  /// Is this a "Darwin" OS (macOS, iOS, tvOS or watchOS).
-  bool isOSDarwin() const {
-    return isMacOSX() || isiOS() || isWatchOS();
-  }
-
-  bool isSimulatorEnvironment() const {
-    return getEnvironment() == Triple::Simulator;
-  }
-
-  bool isMacCatalystEnvironment() const {
-    return getEnvironment() == Triple::MacABI;
-  }
-
-  /// Returns true for targets that run on a macOS machine.
-  bool isTargetMachineMac() const {
-    return isMacOSX() || (isOSDarwin() && (isSimulatorEnvironment() ||
-                                           isMacCatalystEnvironment()));
-  }
-
-  bool isOSNetBSD() const {
-    return getOS() == Triple::NetBSD;
-  }
-
-  bool isOSOpenBSD() const {
-    return getOS() == Triple::OpenBSD;
-  }
-
-  bool isOSFreeBSD() const {
-    return getOS() == Triple::FreeBSD;
-  }
-
-  bool isOSFuchsia() const {
-    return getOS() == Triple::Fuchsia;
-  }
-
-  bool isOSDragonFly() const { return getOS() == Triple::DragonFly; }
-
-  bool isOSSolaris() const {
-    return getOS() == Triple::Solaris;
-  }
-
-  bool isOSIAMCU() const {
-    return getOS() == Triple::ELFIAMCU;
-  }
-
-  bool isOSUnknown() const { return getOS() == Triple::UnknownOS; }
-
-  bool isGNUEnvironment() const {
-    EnvironmentType Env = getEnvironment();
-    return Env == Triple::GNU || Env == Triple::GNUABIN32 ||
-           Env == Triple::GNUABI64 || Env == Triple::GNUEABI ||
-           Env == Triple::GNUEABIHF || Env == Triple::GNUX32;
-  }
-
-  bool isOSContiki() const {
-    return getOS() == Triple::Contiki;
-  }
-
-  /// Tests whether the OS is Haiku.
-  bool isOSHaiku() const {
-    return getOS() == Triple::Haiku;
-  }
-
-  /// Tests whether the OS is Windows.
-  bool isOSWindows() const {
-    return getOS() == Triple::Win32;
-  }
-
-  /// Checks if the environment is MSVC.
-  bool isKnownWindowsMSVCEnvironment() const {
-    return isOSWindows() && getEnvironment() == Triple::MSVC;
-  }
-
-  /// Checks if the environment could be MSVC.
-  bool isWindowsMSVCEnvironment() const {
-    return isKnownWindowsMSVCEnvironment() ||
-           (isOSWindows() && getEnvironment() == Triple::UnknownEnvironment);
-  }
-
-  bool isWindowsCoreCLREnvironment() const {
-    return isOSWindows() && getEnvironment() == Triple::CoreCLR;
-  }
-
-  bool isWindowsItaniumEnvironment() const {
-    return isOSWindows() && getEnvironment() == Triple::Itanium;
-  }
-
-  bool isWindowsCygwinEnvironment() const {
-    return isOSWindows() && getEnvironment() == Triple::Cygnus;
-  }
-
-  bool isWindowsGNUEnvironment() const {
-    return isOSWindows() && getEnvironment() == Triple::GNU;
-  }
-
-  /// Tests for either Cygwin or MinGW OS
-  bool isOSCygMing() const {
-    return isWindowsCygwinEnvironment() || isWindowsGNUEnvironment();
-  }
-
-  /// Is this a "Windows" OS targeting a "MSVCRT.dll" environment.
-  bool isOSMSVCRT() const {
-    return isWindowsMSVCEnvironment() || isWindowsGNUEnvironment() ||
-           isWindowsItaniumEnvironment();
-  }
-
-  /// Tests whether the OS is NaCl (Native Client)
-  bool isOSNaCl() const {
-    return getOS() == Triple::NaCl;
-  }
-
-  /// Tests whether the OS is Linux.
-  bool isOSLinux() const {
-    return getOS() == Triple::Linux;
-  }
-
-  /// Tests whether the OS is kFreeBSD.
-  bool isOSKFreeBSD() const {
-    return getOS() == Triple::KFreeBSD;
-  }
-
-  /// Tests whether the OS is Hurd.
-  bool isOSHurd() const {
-    return getOS() == Triple::Hurd;
-  }
-
-  /// Tests whether the OS is WASI.
-  bool isOSWASI() const {
-    return getOS() == Triple::WASI;
-  }
-
-  /// Tests whether the OS is Emscripten.
-  bool isOSEmscripten() const {
-    return getOS() == Triple::Emscripten;
-  }
-
-  /// Tests whether the OS uses glibc.
-  bool isOSGlibc() const {
-    return (getOS() == Triple::Linux || getOS() == Triple::KFreeBSD ||
-            getOS() == Triple::Hurd) &&
-           !isAndroid();
-  }
-
-  /// Tests whether the OS is AIX.
-  bool isOSAIX() const {
-    return getOS() == Triple::AIX;
-  }
-
-  /// Tests whether the OS uses the ELF binary format.
-  bool isOSBinFormatELF() const {
-    return getObjectFormat() == Triple::ELF;
-  }
-
-  /// Tests whether the OS uses the COFF binary format.
-  bool isOSBinFormatCOFF() const {
-    return getObjectFormat() == Triple::COFF;
-  }
-
-  /// Tests whether the OS uses the GOFF binary format.
-  bool isOSBinFormatGOFF() const { return getObjectFormat() == Triple::GOFF; }
-
-  /// Tests whether the environment is MachO.
-  bool isOSBinFormatMachO() const {
-    return getObjectFormat() == Triple::MachO;
-  }
-
-  /// Tests whether the OS uses the Wasm binary format.
-  bool isOSBinFormatWasm() const {
-    return getObjectFormat() == Triple::Wasm;
-  }
-
-  /// Tests whether the OS uses the XCOFF binary format.
-  bool isOSBinFormatXCOFF() const {
-    return getObjectFormat() == Triple::XCOFF;
-  }
-
-  /// Tests whether the target is the PS4 CPU
-  bool isPS4CPU() const {
-    return getArch() == Triple::x86_64 &&
-           getVendor() == Triple::SCEI &&
-           getOS() == Triple::PS4;
-  }
-
-  /// Tests whether the target is the PS4 platform
-  bool isPS4() const {
-    return getVendor() == Triple::SCEI &&
-           getOS() == Triple::PS4;
-  }
-
-  /// Tests whether the target is Android
-  bool isAndroid() const { return getEnvironment() == Triple::Android; }
-
-  bool isAndroidVersionLT(unsigned Major) const {
-    assert(isAndroid() && "Not an Android triple!");
-
-    VersionTuple Version = getEnvironmentVersion();
-
-    // 64-bit targets did not exist before API level 21 (Lollipop).
-    if (isArch64Bit() && Version.getMajor() < 21)
-      return VersionTuple(21) < VersionTuple(Major);
-
-    return Version < VersionTuple(Major);
-  }
-
-  /// Tests whether the environment is musl-libc
-  bool isMusl() const {
-    return getEnvironment() == Triple::Musl ||
-           getEnvironment() == Triple::MuslEABI ||
-           getEnvironment() == Triple::MuslEABIHF ||
-           getEnvironment() == Triple::MuslX32;
-  }
-
-  /// Tests whether the target is SPIR (32- or 64-bit).
-  bool isSPIR() const {
-    return getArch() == Triple::spir || getArch() == Triple::spir64;
-  }
-
-  /// Tests whether the target is SPIR-V (32/64-bit).
-  bool isSPIRV() const {
-    return getArch() == Triple::spirv32 || getArch() == Triple::spirv64;
-  }
-
-  /// Tests whether the target is NVPTX (32- or 64-bit).
-  bool isNVPTX() const {
-    return getArch() == Triple::nvptx || getArch() == Triple::nvptx64;
-  }
-
-  /// Tests whether the target is AMDGCN
-  bool isAMDGCN() const { return getArch() == Triple::amdgcn; }
-
-  bool isAMDGPU() const {
-    return getArch() == Triple::r600 || getArch() == Triple::amdgcn;
-  }
-
-  /// Tests whether the target is Thumb (little and big endian).
-  bool isThumb() const {
-    return getArch() == Triple::thumb || getArch() == Triple::thumbeb;
-  }
-
-  /// Tests whether the target is ARM (little and big endian).
-  bool isARM() const {
-    return getArch() == Triple::arm || getArch() == Triple::armeb;
-  }
-
-  /// Tests whether the target supports the EHABI exception
-  /// handling standard.
-  bool isTargetEHABICompatible() const {
-    return (isARM() || isThumb()) &&
-           (getEnvironment() == Triple::EABI ||
-            getEnvironment() == Triple::GNUEABI ||
-            getEnvironment() == Triple::MuslEABI ||
-            getEnvironment() == Triple::EABIHF ||
-            getEnvironment() == Triple::GNUEABIHF ||
-            getEnvironment() == Triple::MuslEABIHF || isAndroid()) &&
-           isOSBinFormatELF();
-  }
-
-  /// Tests whether the target is T32.
-  bool isArmT32() const {
-    switch (getSubArch()) {
-    case Triple::ARMSubArch_v8m_baseline:
-    case Triple::ARMSubArch_v7s:
-    case Triple::ARMSubArch_v7k:
-    case Triple::ARMSubArch_v7ve:
-    case Triple::ARMSubArch_v6:
-    case Triple::ARMSubArch_v6m:
-    case Triple::ARMSubArch_v6k:
-    case Triple::ARMSubArch_v6t2:
-    case Triple::ARMSubArch_v5:
-    case Triple::ARMSubArch_v5te:
-    case Triple::ARMSubArch_v4t:
-      return false;
-    default:
-      return true;
-    }
-  }
-
-  /// Tests whether the target is an M-class.
-  bool isArmMClass() const {
-    switch (getSubArch()) {
-    case Triple::ARMSubArch_v6m:
-    case Triple::ARMSubArch_v7m:
-    case Triple::ARMSubArch_v7em:
-    case Triple::ARMSubArch_v8m_mainline:
-    case Triple::ARMSubArch_v8m_baseline:
-    case Triple::ARMSubArch_v8_1m_mainline:
-      return true;
-    default:
-      return false;
-    }
-  }
-
-  /// Tests whether the target is AArch64 (little and big endian).
-  bool isAArch64() const {
-    return getArch() == Triple::aarch64 || getArch() == Triple::aarch64_be ||
-           getArch() == Triple::aarch64_32;
-  }
-
-  /// Tests whether the target is AArch64 and pointers are the size specified by
-  /// \p PointerWidth.
-  bool isAArch64(int PointerWidth) const {
-    assert(PointerWidth == 64 || PointerWidth == 32);
-    if (!isAArch64())
-      return false;
-    return getArch() == Triple::aarch64_32 ||
-                   getEnvironment() == Triple::GNUILP32
-               ? PointerWidth == 32
-               : PointerWidth == 64;
-  }
-
-  /// Tests whether the target is MIPS 32-bit (little and big endian).
-  bool isMIPS32() const {
-    return getArch() == Triple::mips || getArch() == Triple::mipsel;
-  }
-
-  /// Tests whether the target is MIPS 64-bit (little and big endian).
-  bool isMIPS64() const {
-    return getArch() == Triple::mips64 || getArch() == Triple::mips64el;
-  }
-
-  /// Tests whether the target is MIPS (little and big endian, 32- or 64-bit).
-  bool isMIPS() const {
-    return isMIPS32() || isMIPS64();
-  }
-
-  /// Tests whether the target is PowerPC (32- or 64-bit LE or BE).
-  bool isPPC() const {
-    return getArch() == Triple::ppc || getArch() == Triple::ppc64 ||
-           getArch() == Triple::ppcle || getArch() == Triple::ppc64le;
-  }
-
-  /// Tests whether the target is 32-bit PowerPC (little and big endian).
-  bool isPPC32() const {
-    return getArch() == Triple::ppc || getArch() == Triple::ppcle;
-  }
-
-  /// Tests whether the target is 64-bit PowerPC (little and big endian).
-  bool isPPC64() const {
-    return getArch() == Triple::ppc64 || getArch() == Triple::ppc64le;
-  }
-
-  /// Tests whether the target is RISC-V (32- and 64-bit).
-  bool isRISCV() const {
-    return getArch() == Triple::riscv32 || getArch() == Triple::riscv64;
-  }
-
-  /// Tests whether the target is SystemZ.
-  bool isSystemZ() const {
-    return getArch() == Triple::systemz;
-  }
-
-  /// Tests whether the target is x86 (32- or 64-bit).
-  bool isX86() const {
-    return getArch() == Triple::x86 || getArch() == Triple::x86_64;
-  }
-
-  /// Tests whether the target is VE
-  bool isVE() const {
-    return getArch() == Triple::ve;
-  }
-
-  /// Tests whether the target is wasm (32- and 64-bit).
-  bool isWasm() const {
-    return getArch() == Triple::wasm32 || getArch() == Triple::wasm64;
-  }
-
-  // Tests whether the target is CSKY
-  bool isCSKY() const {
-    return getArch() == Triple::csky;
-  }
-
-  /// Tests whether the target is the Apple "arm64e" AArch64 subarch.
-  bool isArm64e() const {
-    return getArch() == Triple::aarch64 &&
-           getSubArch() == Triple::AArch64SubArch_arm64e;
-  }
-
-  /// Tests whether the target is X32.
-  bool isX32() const {
-    EnvironmentType Env = getEnvironment();
-    return Env == Triple::GNUX32 || Env == Triple::MuslX32;
-  }
-
-  /// Tests whether the target supports comdat
-  bool supportsCOMDAT() const {
-    return !(isOSBinFormatMachO() || isOSBinFormatXCOFF());
-  }
-
-  /// Tests whether the target uses emulated TLS as default.
-  bool hasDefaultEmulatedTLS() const {
-    return isAndroid() || isOSOpenBSD() || isWindowsCygwinEnvironment();
-  }
-
-  /// Tests whether the target uses -data-sections as default.
-  bool hasDefaultDataSections() const {
-    return isOSBinFormatXCOFF() || isWasm();
-  }
-
-  /// Tests if the environment supports dllimport/export annotations.
-  bool hasDLLImportExport() const { return isOSWindows() || isPS4CPU(); }
-
-  /// @}
-  /// @name Mutators
-  /// @{
-
-  /// Set the architecture (first) component of the triple to a known type.
-  void setArch(ArchType Kind, SubArchType SubArch = NoSubArch);
-
-  /// Set the vendor (second) component of the triple to a known type.
-  void setVendor(VendorType Kind);
-
-  /// Set the operating system (third) component of the triple to a known type.
-  void setOS(OSType Kind);
-
-  /// Set the environment (fourth) component of the triple to a known type.
-  void setEnvironment(EnvironmentType Kind);
-
-  /// Set the object file format.
-  void setObjectFormat(ObjectFormatType Kind);
-
-  /// Set all components to the new triple \p Str.
-  void setTriple(const Twine &Str);
-
-  /// Set the architecture (first) component of the triple by name.
-  void setArchName(StringRef Str);
-
-  /// Set the vendor (second) component of the triple by name.
-  void setVendorName(StringRef Str);
-
-  /// Set the operating system (third) component of the triple by name.
-  void setOSName(StringRef Str);
-
-  /// Set the optional environment (fourth) component of the triple by name.
-  void setEnvironmentName(StringRef Str);
-
-  /// Set the operating system and optional environment components with a single
-  /// string.
-  void setOSAndEnvironmentName(StringRef Str);
-
-  /// @}
-  /// @name Helpers to build variants of a particular triple.
-  /// @{
-
-  /// Form a triple with a 32-bit variant of the current architecture.
-  ///
-  /// This can be used to move across "families" of architectures where useful.
-  ///
-  /// \returns A new triple with a 32-bit architecture or an unknown
-  ///          architecture if no such variant can be found.
-  llvm::Triple get32BitArchVariant() const;
-
-  /// Form a triple with a 64-bit variant of the current architecture.
-  ///
-  /// This can be used to move across "families" of architectures where useful.
-  ///
-  /// \returns A new triple with a 64-bit architecture or an unknown
-  ///          architecture if no such variant can be found.
-  llvm::Triple get64BitArchVariant() const;
-
-  /// Form a triple with a big endian variant of the current architecture.
-  ///
-  /// This can be used to move across "families" of architectures where useful.
-  ///
-  /// \returns A new triple with a big endian architecture or an unknown
-  ///          architecture if no such variant can be found.
-  llvm::Triple getBigEndianArchVariant() const;
-
-  /// Form a triple with a little endian variant of the current architecture.
-  ///
-  /// This can be used to move across "families" of architectures where useful.
-  ///
-  /// \returns A new triple with a little endian architecture or an unknown
-  ///          architecture if no such variant can be found.
-  llvm::Triple getLittleEndianArchVariant() const;
-
-  /// Get the (LLVM) name of the minimum ARM CPU for the arch we are targeting.
-  ///
-  /// \param Arch the architecture name (e.g., "armv7s"). If it is an empty
-  /// string then the triple's arch name is used.
-  StringRef getARMCPUForArch(StringRef Arch = StringRef()) const;
-
-  /// Tests whether the target triple is little endian.
-  ///
-  /// \returns true if the triple is little endian, false otherwise.
-  bool isLittleEndian() const;
-
-  /// Test whether target triples are compatible.
-  bool isCompatibleWith(const Triple &Other) const;
-
-  /// Merge target triples.
-  std::string merge(const Triple &Other) const;
-
-  /// Some platforms have different minimum supported OS versions that
-  /// varies by the architecture specified in the triple. This function
-  /// returns the minimum supported OS version for this triple if one an exists,
-  /// or an invalid version tuple if this triple doesn't have one.
-  VersionTuple getMinimumSupportedOSVersion() const;
-
-  /// @}
-  /// @name Static helpers for IDs.
-  /// @{
-
-  /// Get the canonical name for the \p Kind architecture.
-  static StringRef getArchTypeName(ArchType Kind);
-
-  /// Get the "prefix" canonical name for the \p Kind architecture. This is the
-  /// prefix used by the architecture specific builtins, and is suitable for
-  /// passing to \see Intrinsic::getIntrinsicForGCCBuiltin().
-  ///
-  /// \return - The architecture prefix, or 0 if none is defined.
-  static StringRef getArchTypePrefix(ArchType Kind);
-
-  /// Get the canonical name for the \p Kind vendor.
-  static StringRef getVendorTypeName(VendorType Kind);
-
-  /// Get the canonical name for the \p Kind operating system.
-  static StringRef getOSTypeName(OSType Kind);
-
-  /// Get the canonical name for the \p Kind environment.
-  static StringRef getEnvironmentTypeName(EnvironmentType Kind);
-
-  /// @}
-  /// @name Static helpers for converting alternate architecture names.
-  /// @{
-
-  /// The canonical type for the given LLVM architecture name (e.g., "x86").
-  static ArchType getArchTypeForLLVMName(StringRef Str);
-
-  /// @}
-
-  /// Returns a canonicalized OS version number for the specified OS.
-  static VersionTuple getCanonicalVersionForOS(OSType OSKind,
-                                               const VersionTuple &Version);
-};
-
-} // End llvm namespace
-
-
-#endif
diff --git a/llvm/include/llvm/ADT/Triple.h b/llvm/include/llvm/ADT/Triple.h
new file mode 120000
index 000000000000..e631bda6dbec
--- /dev/null
+++ b/llvm/include/llvm/ADT/Triple.h
@@ -0,0 +1 @@
+/home/ormastes/dev/pri/toy-riscv-backend/llvm/include/llvm/ADT/Triple.h
\ No newline at end of file
diff --git a/llvm/lib/Support/Triple.cpp b/llvm/lib/Support/Triple.cpp
deleted file mode 100644
index a9afcc9db96a..000000000000
--- a/llvm/lib/Support/Triple.cpp
+++ /dev/null
@@ -1,1813 +0,0 @@
-//===--- Triple.cpp - Target triple helper class --------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "llvm/ADT/Triple.h"
-#include "llvm/ADT/STLArrayExtras.h"
-#include "llvm/ADT/SmallString.h"
-#include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringSwitch.h"
-#include "llvm/Support/ARMTargetParser.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/Host.h"
-#include "llvm/Support/SwapByteOrder.h"
-#include "llvm/Support/VersionTuple.h"
-#include <cassert>
-#include <cstring>
-using namespace llvm;
-
-StringRef Triple::getArchTypeName(ArchType Kind) {
-  switch (Kind) {
-  case UnknownArch:    return "unknown";
-
-  case aarch64:        return "aarch64";
-  case aarch64_32:     return "aarch64_32";
-  case aarch64_be:     return "aarch64_be";
-  case amdgcn:         return "amdgcn";
-  case amdil64:        return "amdil64";
-  case amdil:          return "amdil";
-  case arc:            return "arc";
-  case arm:            return "arm";
-  case armeb:          return "armeb";
-  case avr:            return "avr";
-  case bpfeb:          return "bpfeb";
-  case bpfel:          return "bpfel";
-  case csky:           return "csky";
-  case hexagon:        return "hexagon";
-  case hsail64:        return "hsail64";
-  case hsail:          return "hsail";
-  case kalimba:        return "kalimba";
-  case lanai:          return "lanai";
-  case le32:           return "le32";
-  case le64:           return "le64";
-  case m68k:           return "m68k";
-  case mips64:         return "mips64";
-  case mips64el:       return "mips64el";
-  case mips:           return "mips";
-  case mipsel:         return "mipsel";
-  case msp430:         return "msp430";
-  case nvptx64:        return "nvptx64";
-  case nvptx:          return "nvptx";
-  case ppc64:          return "powerpc64";
-  case ppc64le:        return "powerpc64le";
-  case ppc:            return "powerpc";
-  case ppcle:          return "powerpcle";
-  case r600:           return "r600";
-  case renderscript32: return "renderscript32";
-  case renderscript64: return "renderscript64";
-  case riscv32:        return "riscv32";
-  case riscv64:        return "riscv64";
-  case shave:          return "shave";
-  case sparc:          return "sparc";
-  case sparcel:        return "sparcel";
-  case sparcv9:        return "sparcv9";
-  case spir64:         return "spir64";
-  case spir:           return "spir";
-  case spirv32:        return "spirv32";
-  case spirv64:        return "spirv64";
-  case systemz:        return "s390x";
-  case tce:            return "tce";
-  case tcele:          return "tcele";
-  case thumb:          return "thumb";
-  case thumbeb:        return "thumbeb";
-  case ve:             return "ve";
-  case wasm32:         return "wasm32";
-  case wasm64:         return "wasm64";
-  case x86:            return "i386";
-  case x86_64:         return "x86_64";
-  case xcore:          return "xcore";
-  }
-
-  llvm_unreachable("Invalid ArchType!");
-}
-
-StringRef Triple::getArchTypePrefix(ArchType Kind) {
-  switch (Kind) {
-  default:
-    return StringRef();
-
-  case aarch64:
-  case aarch64_be:
-  case aarch64_32:  return "aarch64";
-
-  case arc:         return "arc";
-
-  case arm:
-  case armeb:
-  case thumb:
-  case thumbeb:     return "arm";
-
-  case avr:         return "avr";
-
-  case ppc64:
-  case ppc64le:
-  case ppc:
-  case ppcle:       return "ppc";
-
-  case m68k:        return "m68k";
-
-  case mips:
-  case mipsel:
-  case mips64:
-  case mips64el:    return "mips";
-
-  case hexagon:     return "hexagon";
-
-  case amdgcn:      return "amdgcn";
-  case r600:        return "r600";
-
-  case bpfel:
-  case bpfeb:       return "bpf";
-
-  case sparcv9:
-  case sparcel:
-  case sparc:       return "sparc";
-
-  case systemz:     return "s390";
-
-  case x86:
-  case x86_64:      return "x86";
-
-  case xcore:       return "xcore";
-
-  // NVPTX intrinsics are namespaced under nvvm.
-  case nvptx:       return "nvvm";
-  case nvptx64:     return "nvvm";
-
-  case le32:        return "le32";
-  case le64:        return "le64";
-
-  case amdil:
-  case amdil64:     return "amdil";
-
-  case hsail:
-  case hsail64:     return "hsail";
-
-  case spir:
-  case spir64:      return "spir";
-
-  case spirv32:
-  case spirv64:     return "spirv";
-
-  case kalimba:     return "kalimba";
-  case lanai:       return "lanai";
-  case shave:       return "shave";
-  case wasm32:
-  case wasm64:      return "wasm";
-
-  case riscv32:
-  case riscv64:     return "riscv";
-
-  case ve:          return "ve";
-  case csky:        return "csky";
-  }
-}
-
-StringRef Triple::getVendorTypeName(VendorType Kind) {
-  switch (Kind) {
-  case UnknownVendor: return "unknown";
-
-  case AMD: return "amd";
-  case Apple: return "apple";
-  case CSR: return "csr";
-  case Freescale: return "fsl";
-  case IBM: return "ibm";
-  case ImaginationTechnologies: return "img";
-  case Mesa: return "mesa";
-  case MipsTechnologies: return "mti";
-  case Myriad: return "myriad";
-  case NVIDIA: return "nvidia";
-  case OpenEmbedded: return "oe";
-  case PC: return "pc";
-  case SCEI: return "scei";
-  case SUSE: return "suse";
-  }
-
-  llvm_unreachable("Invalid VendorType!");
-}
-
-StringRef Triple::getOSTypeName(OSType Kind) {
-  switch (Kind) {
-  case UnknownOS: return "unknown";
-
-  case AIX: return "aix";
-  case AMDHSA: return "amdhsa";
-  case AMDPAL: return "amdpal";
-  case Ananas: return "ananas";
-  case CUDA: return "cuda";
-  case CloudABI: return "cloudabi";
-  case Contiki: return "contiki";
-  case Darwin: return "darwin";
-  case DragonFly: return "dragonfly";
-  case ELFIAMCU: return "elfiamcu";
-  case Emscripten: return "emscripten";
-  case FreeBSD: return "freebsd";
-  case Fuchsia: return "fuchsia";
-  case Haiku: return "haiku";
-  case HermitCore: return "hermit";
-  case Hurd: return "hurd";
-  case IOS: return "ios";
-  case KFreeBSD: return "kfreebsd";
-  case Linux: return "linux";
-  case Lv2: return "lv2";
-  case MacOSX: return "macosx";
-  case Mesa3D: return "mesa3d";
-  case Minix: return "minix";
-  case NVCL: return "nvcl";
-  case NaCl: return "nacl";
-  case NetBSD: return "netbsd";
-  case OpenBSD: return "openbsd";
-  case PS4: return "ps4";
-  case RTEMS: return "rtems";
-  case Solaris: return "solaris";
-  case TvOS: return "tvos";
-  case WASI: return "wasi";
-  case WatchOS: return "watchos";
-  case Win32: return "windows";
-  case ZOS: return "zos";
-  }
-
-  llvm_unreachable("Invalid OSType");
-}
-
-StringRef Triple::getEnvironmentTypeName(EnvironmentType Kind) {
-  switch (Kind) {
-  case UnknownEnvironment: return "unknown";
-  case Android: return "android";
-  case CODE16: return "code16";
-  case CoreCLR: return "coreclr";
-  case Cygnus: return "cygnus";
-  case EABI: return "eabi";
-  case EABIHF: return "eabihf";
-  case GNU: return "gnu";
-  case GNUABI64: return "gnuabi64";
-  case GNUABIN32: return "gnuabin32";
-  case GNUEABI: return "gnueabi";
-  case GNUEABIHF: return "gnueabihf";
-  case GNUX32: return "gnux32";
-  case GNUILP32: return "gnu_ilp32";
-  case Itanium: return "itanium";
-  case MSVC: return "msvc";
-  case MacABI: return "macabi";
-  case Musl: return "musl";
-  case MuslEABI: return "musleabi";
-  case MuslEABIHF: return "musleabihf";
-  case MuslX32: return "muslx32";
-  case Simulator: return "simulator";
-  }
-
-  llvm_unreachable("Invalid EnvironmentType!");
-}
-
-static Triple::ArchType parseBPFArch(StringRef ArchName) {
-  if (ArchName.equals("bpf")) {
-    if (sys::IsLittleEndianHost)
-      return Triple::bpfel;
-    else
-      return Triple::bpfeb;
-  } else if (ArchName.equals("bpf_be") || ArchName.equals("bpfeb")) {
-    return Triple::bpfeb;
-  } else if (ArchName.equals("bpf_le") || ArchName.equals("bpfel")) {
-    return Triple::bpfel;
-  } else {
-    return Triple::UnknownArch;
-  }
-}
-
-Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {
-  Triple::ArchType BPFArch(parseBPFArch(Name));
-  return StringSwitch<Triple::ArchType>(Name)
-    .Case("aarch64", aarch64)
-    .Case("aarch64_be", aarch64_be)
-    .Case("aarch64_32", aarch64_32)
-    .Case("arc", arc)
-    .Case("arm64", aarch64) // "arm64" is an alias for "aarch64"
-    .Case("arm64_32", aarch64_32)
-    .Case("arm", arm)
-    .Case("armeb", armeb)
-    .Case("avr", avr)
-    .StartsWith("bpf", BPFArch)
-    .Case("m68k", m68k)
-    .Case("mips", mips)
-    .Case("mipsel", mipsel)
-    .Case("mips64", mips64)
-    .Case("mips64el", mips64el)
-    .Case("msp430", msp430)
-    .Case("ppc64", ppc64)
-    .Case("ppc32", ppc)
-    .Case("ppc", ppc)
-    .Case("ppc32le", ppcle)
-    .Case("ppcle", ppcle)
-    .Case("ppc64le", ppc64le)
-    .Case("r600", r600)
-    .Case("amdgcn", amdgcn)
-    .Case("riscv32", riscv32)
-    .Case("riscv64", riscv64)
-    .Case("hexagon", hexagon)
-    .Case("sparc", sparc)
-    .Case("sparcel", sparcel)
-    .Case("sparcv9", sparcv9)
-    .Case("systemz", systemz)
-    .Case("tce", tce)
-    .Case("tcele", tcele)
-    .Case("thumb", thumb)
-    .Case("thumbeb", thumbeb)
-    .Case("x86", x86)
-    .Case("x86-64", x86_64)
-    .Case("xcore", xcore)
-    .Case("nvptx", nvptx)
-    .Case("nvptx64", nvptx64)
-    .Case("le32", le32)
-    .Case("le64", le64)
-    .Case("amdil", amdil)
-    .Case("amdil64", amdil64)
-    .Case("hsail", hsail)
-    .Case("hsail64", hsail64)
-    .Case("spir", spir)
-    .Case("spir64", spir64)
-    .Case("spirv32", spirv32)
-    .Case("spirv64", spirv64)
-    .Case("kalimba", kalimba)
-    .Case("lanai", lanai)
-    .Case("shave", shave)
-    .Case("wasm32", wasm32)
-    .Case("wasm64", wasm64)
-    .Case("renderscript32", renderscript32)
-    .Case("renderscript64", renderscript64)
-    .Case("ve", ve)
-    .Case("csky", csky)
-    .Default(UnknownArch);
-}
-
-static Triple::ArchType parseARMArch(StringRef ArchName) {
-  ARM::ISAKind ISA = ARM::parseArchISA(ArchName);
-  ARM::EndianKind ENDIAN = ARM::parseArchEndian(ArchName);
-
-  Triple::ArchType arch = Triple::UnknownArch;
-  switch (ENDIAN) {
-  case ARM::EndianKind::LITTLE: {
-    switch (ISA) {
-    case ARM::ISAKind::ARM:
-      arch = Triple::arm;
-      break;
-    case ARM::ISAKind::THUMB:
-      arch = Triple::thumb;
-      break;
-    case ARM::ISAKind::AARCH64:
-      arch = Triple::aarch64;
-      break;
-    case ARM::ISAKind::INVALID:
-      break;
-    }
-    break;
-  }
-  case ARM::EndianKind::BIG: {
-    switch (ISA) {
-    case ARM::ISAKind::ARM:
-      arch = Triple::armeb;
-      break;
-    case ARM::ISAKind::THUMB:
-      arch = Triple::thumbeb;
-      break;
-    case ARM::ISAKind::AARCH64:
-      arch = Triple::aarch64_be;
-      break;
-    case ARM::ISAKind::INVALID:
-      break;
-    }
-    break;
-  }
-  case ARM::EndianKind::INVALID: {
-    break;
-  }
-  }
-
-  ArchName = ARM::getCanonicalArchName(ArchName);
-  if (ArchName.empty())
-    return Triple::UnknownArch;
-
-  // Thumb only exists in v4+
-  if (ISA == ARM::ISAKind::THUMB &&
-      (ArchName.startswith("v2") || ArchName.startswith("v3")))
-    return Triple::UnknownArch;
-
-  // Thumb only for v6m
-  ARM::ProfileKind Profile = ARM::parseArchProfile(ArchName);
-  unsigned Version = ARM::parseArchVersion(ArchName);
-  if (Profile == ARM::ProfileKind::M && Version == 6) {
-    if (ENDIAN == ARM::EndianKind::BIG)
-      return Triple::thumbeb;
-    else
-      return Triple::thumb;
-  }
-
-  return arch;
-}
-
-static Triple::ArchType parseArch(StringRef ArchName) {
-  auto AT = StringSwitch<Triple::ArchType>(ArchName)
-    .Cases("i386", "i486", "i586", "i686", Triple::x86)
-    // FIXME: Do we need to support these?
-    .Cases("i786", "i886", "i986", Triple::x86)
-    .Cases("amd64", "x86_64", "x86_64h", Triple::x86_64)
-    .Cases("powerpc", "powerpcspe", "ppc", "ppc32", Triple::ppc)
-    .Cases("powerpcle", "ppcle", "ppc32le", Triple::ppcle)
-    .Cases("powerpc64", "ppu", "ppc64", Triple::ppc64)
-    .Cases("powerpc64le", "ppc64le", Triple::ppc64le)
-    .Case("xscale", Triple::arm)
-    .Case("xscaleeb", Triple::armeb)
-    .Case("aarch64", Triple::aarch64)
-    .Case("aarch64_be", Triple::aarch64_be)
-    .Case("aarch64_32", Triple::aarch64_32)
-    .Case("arc", Triple::arc)
-    .Case("arm64", Triple::aarch64)
-    .Case("arm64_32", Triple::aarch64_32)
-    .Case("arm64e", Triple::aarch64)
-    .Case("arm", Triple::arm)
-    .Case("armeb", Triple::armeb)
-    .Case("thumb", Triple::thumb)
-    .Case("thumbeb", Triple::thumbeb)
-    .Case("avr", Triple::avr)
-    .Case("m68k", Triple::m68k)
-    .Case("msp430", Triple::msp430)
-    .Cases("mips", "mipseb", "mipsallegrex", "mipsisa32r6",
-           "mipsr6", Triple::mips)
-    .Cases("mipsel", "mipsallegrexel", "mipsisa32r6el", "mipsr6el",
-           Triple::mipsel)
-    .Cases("mips64", "mips64eb", "mipsn32", "mipsisa64r6",
-           "mips64r6", "mipsn32r6", Triple::mips64)
-    .Cases("mips64el", "mipsn32el", "mipsisa64r6el", "mips64r6el",
-           "mipsn32r6el", Triple::mips64el)
-    .Case("r600", Triple::r600)
-    .Case("amdgcn", Triple::amdgcn)
-    .Case("riscv32", Triple::riscv32)
-    .Case("riscv64", Triple::riscv64)
-    .Case("hexagon", Triple::hexagon)
-    .Cases("s390x", "systemz", Triple::systemz)
-    .Case("sparc", Triple::sparc)
-    .Case("sparcel", Triple::sparcel)
-    .Cases("sparcv9", "sparc64", Triple::sparcv9)
-    .Case("tce", Triple::tce)
-    .Case("tcele", Triple::tcele)
-    .Case("xcore", Triple::xcore)
-    .Case("nvptx", Triple::nvptx)
-    .Case("nvptx64", Triple::nvptx64)
-    .Case("le32", Triple::le32)
-    .Case("le64", Triple::le64)
-    .Case("amdil", Triple::amdil)
-    .Case("amdil64", Triple::amdil64)
-    .Case("hsail", Triple::hsail)
-    .Case("hsail64", Triple::hsail64)
-    .Case("spir", Triple::spir)
-    .Case("spir64", Triple::spir64)
-    .Case("spirv32", Triple::spirv32)
-    .Case("spirv64", Triple::spirv64)
-    .StartsWith("kalimba", Triple::kalimba)
-    .Case("lanai", Triple::lanai)
-    .Case("renderscript32", Triple::renderscript32)
-    .Case("renderscript64", Triple::renderscript64)
-    .Case("shave", Triple::shave)
-    .Case("ve", Triple::ve)
-    .Case("wasm32", Triple::wasm32)
-    .Case("wasm64", Triple::wasm64)
-    .Case("csky", Triple::csky)
-    .Default(Triple::UnknownArch);
-
-  // Some architectures require special parsing logic just to compute the
-  // ArchType result.
-  if (AT == Triple::UnknownArch) {
-    if (ArchName.startswith("arm") || ArchName.startswith("thumb") ||
-        ArchName.startswith("aarch64"))
-      return parseARMArch(ArchName);
-    if (ArchName.startswith("bpf"))
-      return parseBPFArch(ArchName);
-  }
-
-  return AT;
-}
-
-static Triple::VendorType parseVendor(StringRef VendorName) {
-  return StringSwitch<Triple::VendorType>(VendorName)
-    .Case("apple", Triple::Apple)
-    .Case("pc", Triple::PC)
-    .Case("scei", Triple::SCEI)
-    .Case("sie", Triple::SCEI)
-    .Case("fsl", Triple::Freescale)
-    .Case("ibm", Triple::IBM)
-    .Case("img", Triple::ImaginationTechnologies)
-    .Case("mti", Triple::MipsTechnologies)
-    .Case("nvidia", Triple::NVIDIA)
-    .Case("csr", Triple::CSR)
-    .Case("myriad", Triple::Myriad)
-    .Case("amd", Triple::AMD)
-    .Case("mesa", Triple::Mesa)
-    .Case("suse", Triple::SUSE)
-    .Case("oe", Triple::OpenEmbedded)
-    .Default(Triple::UnknownVendor);
-}
-
-static Triple::OSType parseOS(StringRef OSName) {
-  return StringSwitch<Triple::OSType>(OSName)
-    .StartsWith("ananas", Triple::Ananas)
-    .StartsWith("cloudabi", Triple::CloudABI)
-    .StartsWith("darwin", Triple::Darwin)
-    .StartsWith("dragonfly", Triple::DragonFly)
-    .StartsWith("freebsd", Triple::FreeBSD)
-    .StartsWith("fuchsia", Triple::Fuchsia)
-    .StartsWith("ios", Triple::IOS)
-    .StartsWith("kfreebsd", Triple::KFreeBSD)
-    .StartsWith("linux", Triple::Linux)
-    .StartsWith("lv2", Triple::Lv2)
-    .StartsWith("macos", Triple::MacOSX)
-    .StartsWith("netbsd", Triple::NetBSD)
-    .StartsWith("openbsd", Triple::OpenBSD)
-    .StartsWith("solaris", Triple::Solaris)
-    .StartsWith("win32", Triple::Win32)
-    .StartsWith("windows", Triple::Win32)
-    .StartsWith("zos", Triple::ZOS)
-    .StartsWith("haiku", Triple::Haiku)
-    .StartsWith("minix", Triple::Minix)
-    .StartsWith("rtems", Triple::RTEMS)
-    .StartsWith("nacl", Triple::NaCl)
-    .StartsWith("aix", Triple::AIX)
-    .StartsWith("cuda", Triple::CUDA)
-    .StartsWith("nvcl", Triple::NVCL)
-    .StartsWith("amdhsa", Triple::AMDHSA)
-    .StartsWith("ps4", Triple::PS4)
-    .StartsWith("elfiamcu", Triple::ELFIAMCU)
-    .StartsWith("tvos", Triple::TvOS)
-    .StartsWith("watchos", Triple::WatchOS)
-    .StartsWith("mesa3d", Triple::Mesa3D)
-    .StartsWith("contiki", Triple::Contiki)
-    .StartsWith("amdpal", Triple::AMDPAL)
-    .StartsWith("hermit", Triple::HermitCore)
-    .StartsWith("hurd", Triple::Hurd)
-    .StartsWith("wasi", Triple::WASI)
-    .StartsWith("emscripten", Triple::Emscripten)
-    .Default(Triple::UnknownOS);
-}
-
-static Triple::EnvironmentType parseEnvironment(StringRef EnvironmentName) {
-  return StringSwitch<Triple::EnvironmentType>(EnvironmentName)
-      .StartsWith("eabihf", Triple::EABIHF)
-      .StartsWith("eabi", Triple::EABI)
-      .StartsWith("gnuabin32", Triple::GNUABIN32)
-      .StartsWith("gnuabi64", Triple::GNUABI64)
-      .StartsWith("gnueabihf", Triple::GNUEABIHF)
-      .StartsWith("gnueabi", Triple::GNUEABI)
-      .StartsWith("gnux32", Triple::GNUX32)
-      .StartsWith("gnu_ilp32", Triple::GNUILP32)
-      .StartsWith("code16", Triple::CODE16)
-      .StartsWith("gnu", Triple::GNU)
-      .StartsWith("android", Triple::Android)
-      .StartsWith("musleabihf", Triple::MuslEABIHF)
-      .StartsWith("musleabi", Triple::MuslEABI)
-      .StartsWith("muslx32", Triple::MuslX32)
-      .StartsWith("musl", Triple::Musl)
-      .StartsWith("msvc", Triple::MSVC)
-      .StartsWith("itanium", Triple::Itanium)
-      .StartsWith("cygnus", Triple::Cygnus)
-      .StartsWith("coreclr", Triple::CoreCLR)
-      .StartsWith("simulator", Triple::Simulator)
-      .StartsWith("macabi", Triple::MacABI)
-      .Default(Triple::UnknownEnvironment);
-}
-
-static Triple::ObjectFormatType parseFormat(StringRef EnvironmentName) {
-  return StringSwitch<Triple::ObjectFormatType>(EnvironmentName)
-    // "xcoff" must come before "coff" because of the order-dependendent
-    // pattern matching.
-    .EndsWith("xcoff", Triple::XCOFF)
-    .EndsWith("coff", Triple::COFF)
-    .EndsWith("elf", Triple::ELF)
-    .EndsWith("goff", Triple::GOFF)
-    .EndsWith("macho", Triple::MachO)
-    .EndsWith("wasm", Triple::Wasm)
-    .Default(Triple::UnknownObjectFormat);
-}
-
-static Triple::SubArchType parseSubArch(StringRef SubArchName) {
-  if (SubArchName.startswith("mips") &&
-      (SubArchName.endswith("r6el") || SubArchName.endswith("r6")))
-    return Triple::MipsSubArch_r6;
-
-  if (SubArchName == "powerpcspe")
-    return Triple::PPCSubArch_spe;
-
-  if (SubArchName == "arm64e")
-    return Triple::AArch64SubArch_arm64e;
-
-  StringRef ARMSubArch = ARM::getCanonicalArchName(SubArchName);
-
-  // For now, this is the small part. Early return.
-  if (ARMSubArch.empty())
-    return StringSwitch<Triple::SubArchType>(SubArchName)
-      .EndsWith("kalimba3", Triple::KalimbaSubArch_v3)
-      .EndsWith("kalimba4", Triple::KalimbaSubArch_v4)
-      .EndsWith("kalimba5", Triple::KalimbaSubArch_v5)
-      .Default(Triple::NoSubArch);
-
-  // ARM sub arch.
-  switch(ARM::parseArch(ARMSubArch)) {
-  case ARM::ArchKind::ARMV4:
-    return Triple::NoSubArch;
-  case ARM::ArchKind::ARMV4T:
-    return Triple::ARMSubArch_v4t;
-  case ARM::ArchKind::ARMV5T:
-    return Triple::ARMSubArch_v5;
-  case ARM::ArchKind::ARMV5TE:
-  case ARM::ArchKind::IWMMXT:
-  case ARM::ArchKind::IWMMXT2:
-  case ARM::ArchKind::XSCALE:
-  case ARM::ArchKind::ARMV5TEJ:
-    return Triple::ARMSubArch_v5te;
-  case ARM::ArchKind::ARMV6:
-    return Triple::ARMSubArch_v6;
-  case ARM::ArchKind::ARMV6K:
-  case ARM::ArchKind::ARMV6KZ:
-    return Triple::ARMSubArch_v6k;
-  case ARM::ArchKind::ARMV6T2:
-    return Triple::ARMSubArch_v6t2;
-  case ARM::ArchKind::ARMV6M:
-    return Triple::ARMSubArch_v6m;
-  case ARM::ArchKind::ARMV7A:
-  case ARM::ArchKind::ARMV7R:
-    return Triple::ARMSubArch_v7;
-  case ARM::ArchKind::ARMV7VE:
-    return Triple::ARMSubArch_v7ve;
-  case ARM::ArchKind::ARMV7K:
-    return Triple::ARMSubArch_v7k;
-  case ARM::ArchKind::ARMV7M:
-    return Triple::ARMSubArch_v7m;
-  case ARM::ArchKind::ARMV7S:
-    return Triple::ARMSubArch_v7s;
-  case ARM::ArchKind::ARMV7EM:
-    return Triple::ARMSubArch_v7em;
-  case ARM::ArchKind::ARMV8A:
-    return Triple::ARMSubArch_v8;
-  case ARM::ArchKind::ARMV8_1A:
-    return Triple::ARMSubArch_v8_1a;
-  case ARM::ArchKind::ARMV8_2A:
-    return Triple::ARMSubArch_v8_2a;
-  case ARM::ArchKind::ARMV8_3A:
-    return Triple::ARMSubArch_v8_3a;
-  case ARM::ArchKind::ARMV8_4A:
-    return Triple::ARMSubArch_v8_4a;
-  case ARM::ArchKind::ARMV8_5A:
-    return Triple::ARMSubArch_v8_5a;
-  case ARM::ArchKind::ARMV8_6A:
-    return Triple::ARMSubArch_v8_6a;
-  case ARM::ArchKind::ARMV8_7A:
-    return Triple::ARMSubArch_v8_7a;
-  case ARM::ArchKind::ARMV8_8A:
-    return Triple::ARMSubArch_v8_8a;
-  case ARM::ArchKind::ARMV9A:
-    return Triple::ARMSubArch_v9;
-  case ARM::ArchKind::ARMV9_1A:
-    return Triple::ARMSubArch_v9_1a;
-  case ARM::ArchKind::ARMV9_2A:
-    return Triple::ARMSubArch_v9_2a;
-  case ARM::ArchKind::ARMV9_3A:
-    return Triple::ARMSubArch_v9_3a;
-  case ARM::ArchKind::ARMV8R:
-    return Triple::ARMSubArch_v8r;
-  case ARM::ArchKind::ARMV8MBaseline:
-    return Triple::ARMSubArch_v8m_baseline;
-  case ARM::ArchKind::ARMV8MMainline:
-    return Triple::ARMSubArch_v8m_mainline;
-  case ARM::ArchKind::ARMV8_1MMainline:
-    return Triple::ARMSubArch_v8_1m_mainline;
-  default:
-    return Triple::NoSubArch;
-  }
-}
-
-static StringRef getObjectFormatTypeName(Triple::ObjectFormatType Kind) {
-  switch (Kind) {
-  case Triple::UnknownObjectFormat: return "";
-  case Triple::COFF:  return "coff";
-  case Triple::ELF:   return "elf";
-  case Triple::GOFF:  return "goff";
-  case Triple::MachO: return "macho";
-  case Triple::Wasm:  return "wasm";
-  case Triple::XCOFF: return "xcoff";
-  }
-  llvm_unreachable("unknown object format type");
-}
-
-static Triple::ObjectFormatType getDefaultFormat(const Triple &T) {
-  switch (T.getArch()) {
-  case Triple::UnknownArch:
-  case Triple::aarch64:
-  case Triple::aarch64_32:
-  case Triple::arm:
-  case Triple::thumb:
-  case Triple::x86:
-  case Triple::x86_64:
-    if (T.isOSDarwin())
-      return Triple::MachO;
-    else if (T.isOSWindows())
-      return Triple::COFF;
-    return Triple::ELF;
-
-  case Triple::aarch64_be:
-  case Triple::amdgcn:
-  case Triple::amdil64:
-  case Triple::amdil:
-  case Triple::arc:
-  case Triple::armeb:
-  case Triple::avr:
-  case Triple::bpfeb:
-  case Triple::bpfel:
-  case Triple::csky:
-  case Triple::hexagon:
-  case Triple::hsail64:
-  case Triple::hsail:
-  case Triple::kalimba:
-  case Triple::lanai:
-  case Triple::le32:
-  case Triple::le64:
-  case Triple::m68k:
-  case Triple::mips64:
-  case Triple::mips64el:
-  case Triple::mips:
-  case Triple::mipsel:
-  case Triple::msp430:
-  case Triple::nvptx64:
-  case Triple::nvptx:
-  case Triple::ppc64le:
-  case Triple::ppcle:
-  case Triple::r600:
-  case Triple::renderscript32:
-  case Triple::renderscript64:
-  case Triple::riscv32:
-  case Triple::riscv64:
-  case Triple::shave:
-  case Triple::sparc:
-  case Triple::sparcel:
-  case Triple::sparcv9:
-  case Triple::spir64:
-  case Triple::spir:
-  case Triple::tce:
-  case Triple::tcele:
-  case Triple::thumbeb:
-  case Triple::ve:
-  case Triple::xcore:
-    return Triple::ELF;
-
-  case Triple::ppc64:
-  case Triple::ppc:
-    if (T.isOSAIX())
-      return Triple::XCOFF;
-    return Triple::ELF;
-
-  case Triple::systemz:
-    if (T.isOSzOS())
-      return Triple::GOFF;
-    return Triple::ELF;
-
-  case Triple::wasm32:
-  case Triple::wasm64:
-    return Triple::Wasm;
-
-  case Triple::spirv32:
-  case Triple::spirv64:
-    // TODO: In future this will be Triple::SPIRV.
-    return Triple::UnknownObjectFormat;
-  }
-  llvm_unreachable("unknown architecture");
-}
-
-/// Construct a triple from the string representation provided.
-///
-/// This stores the string representation and parses the various pieces into
-/// enum members.
-Triple::Triple(const Twine &Str)
-    : Data(Str.str()), Arch(UnknownArch), SubArch(NoSubArch),
-      Vendor(UnknownVendor), OS(UnknownOS), Environment(UnknownEnvironment),
-      ObjectFormat(UnknownObjectFormat) {
-  // Do minimal parsing by hand here.
-  SmallVector<StringRef, 4> Components;
-  StringRef(Data).split(Components, '-', /*MaxSplit*/ 3);
-  if (Components.size() > 0) {
-    Arch = parseArch(Components[0]);
-    SubArch = parseSubArch(Components[0]);
-    if (Components.size() > 1) {
-      Vendor = parseVendor(Components[1]);
-      if (Components.size() > 2) {
-        OS = parseOS(Components[2]);
-        if (Components.size() > 3) {
-          Environment = parseEnvironment(Components[3]);
-          ObjectFormat = parseFormat(Components[3]);
-        }
-      }
-    } else {
-      Environment =
-          StringSwitch<Triple::EnvironmentType>(Components[0])
-              .StartsWith("mipsn32", Triple::GNUABIN32)
-              .StartsWith("mips64", Triple::GNUABI64)
-              .StartsWith("mipsisa64", Triple::GNUABI64)
-              .StartsWith("mipsisa32", Triple::GNU)
-              .Cases("mips", "mipsel", "mipsr6", "mipsr6el", Triple::GNU)
-              .Default(UnknownEnvironment);
-    }
-  }
-  if (ObjectFormat == UnknownObjectFormat)
-    ObjectFormat = getDefaultFormat(*this);
-}
-
-/// Construct a triple from string representations of the architecture,
-/// vendor, and OS.
-///
-/// This joins each argument into a canonical string representation and parses
-/// them into enum members. It leaves the environment unknown and omits it from
-/// the string representation.
-Triple::Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr)
-    : Data((ArchStr + Twine('-') + VendorStr + Twine('-') + OSStr).str()),
-      Arch(parseArch(ArchStr.str())),
-      SubArch(parseSubArch(ArchStr.str())),
-      Vendor(parseVendor(VendorStr.str())),
-      OS(parseOS(OSStr.str())),
-      Environment(), ObjectFormat(Triple::UnknownObjectFormat) {
-  ObjectFormat = getDefaultFormat(*this);
-}
-
-/// Construct a triple from string representations of the architecture,
-/// vendor, OS, and environment.
-///
-/// This joins each argument into a canonical string representation and parses
-/// them into enum members.
-Triple::Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr,
-               const Twine &EnvironmentStr)
-    : Data((ArchStr + Twine('-') + VendorStr + Twine('-') + OSStr + Twine('-') +
-            EnvironmentStr).str()),
-      Arch(parseArch(ArchStr.str())),
-      SubArch(parseSubArch(ArchStr.str())),
-      Vendor(parseVendor(VendorStr.str())),
-      OS(parseOS(OSStr.str())),
-      Environment(parseEnvironment(EnvironmentStr.str())),
-      ObjectFormat(parseFormat(EnvironmentStr.str())) {
-  if (ObjectFormat == Triple::UnknownObjectFormat)
-    ObjectFormat = getDefaultFormat(*this);
-}
-
-std::string Triple::normalize(StringRef Str) {
-  bool IsMinGW32 = false;
-  bool IsCygwin = false;
-
-  // Parse into components.
-  SmallVector<StringRef, 4> Components;
-  Str.split(Components, '-');
-
-  // If the first component corresponds to a known architecture, preferentially
-  // use it for the architecture.  If the second component corresponds to a
-  // known vendor, preferentially use it for the vendor, etc.  This avoids silly
-  // component movement when a component parses as (eg) both a valid arch and a
-  // valid os.
-  ArchType Arch = UnknownArch;
-  if (Components.size() > 0)
-    Arch = parseArch(Components[0]);
-  VendorType Vendor = UnknownVendor;
-  if (Components.size() > 1)
-    Vendor = parseVendor(Components[1]);
-  OSType OS = UnknownOS;
-  if (Components.size() > 2) {
-    OS = parseOS(Components[2]);
-    IsCygwin = Components[2].startswith("cygwin");
-    IsMinGW32 = Components[2].startswith("mingw");
-  }
-  EnvironmentType Environment = UnknownEnvironment;
-  if (Components.size() > 3)
-    Environment = parseEnvironment(Components[3]);
-  ObjectFormatType ObjectFormat = UnknownObjectFormat;
-  if (Components.size() > 4)
-    ObjectFormat = parseFormat(Components[4]);
-
-  // Note which components are already in their final position.  These will not
-  // be moved.
-  bool Found[4];
-  Found[0] = Arch != UnknownArch;
-  Found[1] = Vendor != UnknownVendor;
-  Found[2] = OS != UnknownOS;
-  Found[3] = Environment != UnknownEnvironment;
-
-  // If they are not there already, permute the components into their canonical
-  // positions by seeing if they parse as a valid architecture, and if so moving
-  // the component to the architecture position etc.
-  for (unsigned Pos = 0; Pos != array_lengthof(Found); ++Pos) {
-    if (Found[Pos])
-      continue; // Already in the canonical position.
-
-    for (unsigned Idx = 0; Idx != Components.size(); ++Idx) {
-      // Do not reparse any components that already matched.
-      if (Idx < array_lengthof(Found) && Found[Idx])
-        continue;
-
-      // Does this component parse as valid for the target position?
-      bool Valid = false;
-      StringRef Comp = Components[Idx];
-      switch (Pos) {
-      default: llvm_unreachable("unexpected component type!");
-      case 0:
-        Arch = parseArch(Comp);
-        Valid = Arch != UnknownArch;
-        break;
-      case 1:
-        Vendor = parseVendor(Comp);
-        Valid = Vendor != UnknownVendor;
-        break;
-      case 2:
-        OS = parseOS(Comp);
-        IsCygwin = Comp.startswith("cygwin");
-        IsMinGW32 = Comp.startswith("mingw");
-        Valid = OS != UnknownOS || IsCygwin || IsMinGW32;
-        break;
-      case 3:
-        Environment = parseEnvironment(Comp);
-        Valid = Environment != UnknownEnvironment;
-        if (!Valid) {
-          ObjectFormat = parseFormat(Comp);
-          Valid = ObjectFormat != UnknownObjectFormat;
-        }
-        break;
-      }
-      if (!Valid)
-        continue; // Nope, try the next component.
-
-      // Move the component to the target position, pushing any non-fixed
-      // components that are in the way to the right.  This tends to give
-      // good results in the common cases of a forgotten vendor component
-      // or a wrongly positioned environment.
-      if (Pos < Idx) {
-        // Insert left, pushing the existing components to the right.  For
-        // example, a-b-i386 -> i386-a-b when moving i386 to the front.
-        StringRef CurrentComponent(""); // The empty component.
-        // Replace the component we are moving with an empty component.
-        std::swap(CurrentComponent, Components[Idx]);
-        // Insert the component being moved at Pos, displacing any existing
-        // components to the right.
-        for (unsigned i = Pos; !CurrentComponent.empty(); ++i) {
-          // Skip over any fixed components.
-          while (i < array_lengthof(Found) && Found[i])
-            ++i;
-          // Place the component at the new position, getting the component
-          // that was at this position - it will be moved right.
-          std::swap(CurrentComponent, Components[i]);
-        }
-      } else if (Pos > Idx) {
-        // Push right by inserting empty components until the component at Idx
-        // reaches the target position Pos.  For example, pc-a -> -pc-a when
-        // moving pc to the second position.
-        do {
-          // Insert one empty component at Idx.
-          StringRef CurrentComponent(""); // The empty component.
-          for (unsigned i = Idx; i < Components.size();) {
-            // Place the component at the new position, getting the component
-            // that was at this position - it will be moved right.
-            std::swap(CurrentComponent, Components[i]);
-            // If it was placed on top of an empty component then we are done.
-            if (CurrentComponent.empty())
-              break;
-            // Advance to the next component, skipping any fixed components.
-            while (++i < array_lengthof(Found) && Found[i])
-              ;
-          }
-          // The last component was pushed off the end - append it.
-          if (!CurrentComponent.empty())
-            Components.push_back(CurrentComponent);
-
-          // Advance Idx to the component's new position.
-          while (++Idx < array_lengthof(Found) && Found[Idx])
-            ;
-        } while (Idx < Pos); // Add more until the final position is reached.
-      }
-      assert(Pos < Components.size() && Components[Pos] == Comp &&
-             "Component moved wrong!");
-      Found[Pos] = true;
-      break;
-    }
-  }
-
-  // Replace empty components with "unknown" value.
-  for (StringRef &C : Components)
-    if (C.empty())
-      C = "unknown";
-
-  // Special case logic goes here.  At this point Arch, Vendor and OS have the
-  // correct values for the computed components.
-  std::string NormalizedEnvironment;
-  if (Environment == Triple::Android && Components[3].startswith("androideabi")) {
-    StringRef AndroidVersion = Components[3].drop_front(strlen("androideabi"));
-    if (AndroidVersion.empty()) {
-      Components[3] = "android";
-    } else {
-      NormalizedEnvironment = Twine("android", AndroidVersion).str();
-      Components[3] = NormalizedEnvironment;
-    }
-  }
-
-  // SUSE uses "gnueabi" to mean "gnueabihf"
-  if (Vendor == Triple::SUSE && Environment == llvm::Triple::GNUEABI)
-    Components[3] = "gnueabihf";
-
-  if (OS == Triple::Win32) {
-    Components.resize(4);
-    Components[2] = "windows";
-    if (Environment == UnknownEnvironment) {
-      if (ObjectFormat == UnknownObjectFormat || ObjectFormat == Triple::COFF)
-        Components[3] = "msvc";
-      else
-        Components[3] = getObjectFormatTypeName(ObjectFormat);
-    }
-  } else if (IsMinGW32) {
-    Components.resize(4);
-    Components[2] = "windows";
-    Components[3] = "gnu";
-  } else if (IsCygwin) {
-    Components.resize(4);
-    Components[2] = "windows";
-    Components[3] = "cygnus";
-  }
-  if (IsMinGW32 || IsCygwin ||
-      (OS == Triple::Win32 && Environment != UnknownEnvironment)) {
-    if (ObjectFormat != UnknownObjectFormat && ObjectFormat != Triple::COFF) {
-      Components.resize(5);
-      Components[4] = getObjectFormatTypeName(ObjectFormat);
-    }
-  }
-
-  // Stick the corrected components back together to form the normalized string.
-  return join(Components, "-");
-}
-
-StringRef Triple::getArchName() const {
-  return StringRef(Data).split('-').first;           // Isolate first component
-}
-
-StringRef Triple::getArchName(ArchType Kind, SubArchType SubArch) const {
-  switch (Kind) {
-  case Triple::mips:
-    if (SubArch == MipsSubArch_r6)
-      return "mipsisa32r6";
-    break;
-  case Triple::mipsel:
-    if (SubArch == MipsSubArch_r6)
-      return "mipsisa32r6el";
-    break;
-  case Triple::mips64:
-    if (SubArch == MipsSubArch_r6)
-      return "mipsisa64r6";
-    break;
-  case Triple::mips64el:
-    if (SubArch == MipsSubArch_r6)
-      return "mipsisa64r6el";
-    break;
-  default:
-    break;
-  }
-  return getArchTypeName(Kind);
-}
-
-StringRef Triple::getVendorName() const {
-  StringRef Tmp = StringRef(Data).split('-').second; // Strip first component
-  return Tmp.split('-').first;                       // Isolate second component
-}
-
-StringRef Triple::getOSName() const {
-  StringRef Tmp = StringRef(Data).split('-').second; // Strip first component
-  Tmp = Tmp.split('-').second;                       // Strip second component
-  return Tmp.split('-').first;                       // Isolate third component
-}
-
-StringRef Triple::getEnvironmentName() const {
-  StringRef Tmp = StringRef(Data).split('-').second; // Strip first component
-  Tmp = Tmp.split('-').second;                       // Strip second component
-  return Tmp.split('-').second;                      // Strip third component
-}
-
-StringRef Triple::getOSAndEnvironmentName() const {
-  StringRef Tmp = StringRef(Data).split('-').second; // Strip first component
-  return Tmp.split('-').second;                      // Strip second component
-}
-
-static VersionTuple parseVersionFromName(StringRef Name) {
-  VersionTuple Version;
-  Version.tryParse(Name);
-  return Version.withoutBuild();
-}
-
-VersionTuple Triple::getEnvironmentVersion() const {
-  StringRef EnvironmentName = getEnvironmentName();
-  StringRef EnvironmentTypeName = getEnvironmentTypeName(getEnvironment());
-  if (EnvironmentName.startswith(EnvironmentTypeName))
-    EnvironmentName = EnvironmentName.substr(EnvironmentTypeName.size());
-
-  return parseVersionFromName(EnvironmentName);
-}
-
-VersionTuple Triple::getOSVersion() const {
-  StringRef OSName = getOSName();
-  // Assume that the OS portion of the triple starts with the canonical name.
-  StringRef OSTypeName = getOSTypeName(getOS());
-  if (OSName.startswith(OSTypeName))
-    OSName = OSName.substr(OSTypeName.size());
-  else if (getOS() == MacOSX)
-    OSName.consume_front("macos");
-
-  return parseVersionFromName(OSName);
-}
-
-bool Triple::getMacOSXVersion(VersionTuple &Version) const {
-  Version = getOSVersion();
-
-  switch (getOS()) {
-  default: llvm_unreachable("unexpected OS for Darwin triple");
-  case Darwin:
-    // Default to darwin8, i.e., MacOSX 10.4.
-    if (Version.getMajor() == 0)
-      Version = VersionTuple(8);
-    // Darwin version numbers are skewed from OS X versions.
-    if (Version.getMajor() < 4) {
-      return false;
-    }
-    if (Version.getMajor() <= 19) {
-      Version = VersionTuple(10, Version.getMajor() - 4);
-    } else {
-      // darwin20+ corresponds to macOS 11+.
-      Version = VersionTuple(11 + Version.getMajor() - 20);
-    }
-    break;
-  case MacOSX:
-    // Default to 10.4.
-    if (Version.getMajor() == 0) {
-      Version = VersionTuple(10, 4);
-    } else if (Version.getMajor() < 10) {
-      return false;
-    }
-    break;
-  case IOS:
-  case TvOS:
-  case WatchOS:
-    // Ignore the version from the triple.  This is only handled because the
-    // the clang driver combines OS X and IOS support into a common Darwin
-    // toolchain that wants to know the OS X version number even when targeting
-    // IOS.
-    Version = VersionTuple(10, 4);
-    break;
-  }
-  return true;
-}
-
-VersionTuple Triple::getiOSVersion() const {
-  switch (getOS()) {
-  default: llvm_unreachable("unexpected OS for Darwin triple");
-  case Darwin:
-  case MacOSX:
-    // Ignore the version from the triple.  This is only handled because the
-    // the clang driver combines OS X and IOS support into a common Darwin
-    // toolchain that wants to know the iOS version number even when targeting
-    // OS X.
-    return VersionTuple(5);
-  case IOS:
-  case TvOS: {
-    VersionTuple Version = getOSVersion();
-    // Default to 5.0 (or 7.0 for arm64).
-    if (Version.getMajor() == 0)
-      return (getArch() == aarch64) ? VersionTuple(7) : VersionTuple(5);
-    return Version;
-  }
-  case WatchOS:
-    llvm_unreachable("conflicting triple info");
-  }
-}
-
-VersionTuple Triple::getWatchOSVersion() const {
-  switch (getOS()) {
-  default: llvm_unreachable("unexpected OS for Darwin triple");
-  case Darwin:
-  case MacOSX:
-    // Ignore the version from the triple.  This is only handled because the
-    // the clang driver combines OS X and IOS support into a common Darwin
-    // toolchain that wants to know the iOS version number even when targeting
-    // OS X.
-    return VersionTuple(2);
-  case WatchOS: {
-    VersionTuple Version = getOSVersion();
-    if (Version.getMajor() == 0)
-      return VersionTuple(2);
-    return Version;
-  }
-  case IOS:
-    llvm_unreachable("conflicting triple info");
-  }
-}
-
-void Triple::setTriple(const Twine &Str) {
-  *this = Triple(Str);
-}
-
-void Triple::setArch(ArchType Kind, SubArchType SubArch) {
-  setArchName(getArchName(Kind, SubArch));
-}
-
-void Triple::setVendor(VendorType Kind) {
-  setVendorName(getVendorTypeName(Kind));
-}
-
-void Triple::setOS(OSType Kind) {
-  setOSName(getOSTypeName(Kind));
-}
-
-void Triple::setEnvironment(EnvironmentType Kind) {
-  if (ObjectFormat == getDefaultFormat(*this))
-    return setEnvironmentName(getEnvironmentTypeName(Kind));
-
-  setEnvironmentName((getEnvironmentTypeName(Kind) + Twine("-") +
-                      getObjectFormatTypeName(ObjectFormat)).str());
-}
-
-void Triple::setObjectFormat(ObjectFormatType Kind) {
-  if (Environment == UnknownEnvironment)
-    return setEnvironmentName(getObjectFormatTypeName(Kind));
-
-  setEnvironmentName((getEnvironmentTypeName(Environment) + Twine("-") +
-                      getObjectFormatTypeName(Kind)).str());
-}
-
-void Triple::setArchName(StringRef Str) {
-  // Work around a miscompilation bug for Twines in gcc 4.0.3.
-  SmallString<64> Triple;
-  Triple += Str;
-  Triple += "-";
-  Triple += getVendorName();
-  Triple += "-";
-  Triple += getOSAndEnvironmentName();
-  setTriple(Triple);
-}
-
-void Triple::setVendorName(StringRef Str) {
-  setTriple(getArchName() + "-" + Str + "-" + getOSAndEnvironmentName());
-}
-
-void Triple::setOSName(StringRef Str) {
-  if (hasEnvironment())
-    setTriple(getArchName() + "-" + getVendorName() + "-" + Str +
-              "-" + getEnvironmentName());
-  else
-    setTriple(getArchName() + "-" + getVendorName() + "-" + Str);
-}
-
-void Triple::setEnvironmentName(StringRef Str) {
-  setTriple(getArchName() + "-" + getVendorName() + "-" + getOSName() +
-            "-" + Str);
-}
-
-void Triple::setOSAndEnvironmentName(StringRef Str) {
-  setTriple(getArchName() + "-" + getVendorName() + "-" + Str);
-}
-
-static unsigned getArchPointerBitWidth(llvm::Triple::ArchType Arch) {
-  switch (Arch) {
-  case llvm::Triple::UnknownArch:
-    return 0;
-
-  case llvm::Triple::avr:
-  case llvm::Triple::msp430:
-    return 16;
-
-  case llvm::Triple::aarch64_32:
-  case llvm::Triple::amdil:
-  case llvm::Triple::arc:
-  case llvm::Triple::arm:
-  case llvm::Triple::armeb:
-  case llvm::Triple::csky:
-  case llvm::Triple::hexagon:
-  case llvm::Triple::hsail:
-  case llvm::Triple::kalimba:
-  case llvm::Triple::lanai:
-  case llvm::Triple::le32:
-  case llvm::Triple::m68k:
-  case llvm::Triple::mips:
-  case llvm::Triple::mipsel:
-  case llvm::Triple::nvptx:
-  case llvm::Triple::ppc:
-  case llvm::Triple::ppcle:
-  case llvm::Triple::r600:
-  case llvm::Triple::renderscript32:
-  case llvm::Triple::riscv32:
-  case llvm::Triple::shave:
-  case llvm::Triple::sparc:
-  case llvm::Triple::sparcel:
-  case llvm::Triple::spir:
-  case llvm::Triple::spirv32:
-  case llvm::Triple::tce:
-  case llvm::Triple::tcele:
-  case llvm::Triple::thumb:
-  case llvm::Triple::thumbeb:
-  case llvm::Triple::wasm32:
-  case llvm::Triple::x86:
-  case llvm::Triple::xcore:
-    return 32;
-
-  case llvm::Triple::aarch64:
-  case llvm::Triple::aarch64_be:
-  case llvm::Triple::amdgcn:
-  case llvm::Triple::amdil64:
-  case llvm::Triple::bpfeb:
-  case llvm::Triple::bpfel:
-  case llvm::Triple::hsail64:
-  case llvm::Triple::le64:
-  case llvm::Triple::mips64:
-  case llvm::Triple::mips64el:
-  case llvm::Triple::nvptx64:
-  case llvm::Triple::ppc64:
-  case llvm::Triple::ppc64le:
-  case llvm::Triple::renderscript64:
-  case llvm::Triple::riscv64:
-  case llvm::Triple::sparcv9:
-  case llvm::Triple::spir64:
-  case llvm::Triple::spirv64:
-  case llvm::Triple::systemz:
-  case llvm::Triple::ve:
-  case llvm::Triple::wasm64:
-  case llvm::Triple::x86_64:
-    return 64;
-  }
-  llvm_unreachable("Invalid architecture value");
-}
-
-bool Triple::isArch64Bit() const {
-  return getArchPointerBitWidth(getArch()) == 64;
-}
-
-bool Triple::isArch32Bit() const {
-  return getArchPointerBitWidth(getArch()) == 32;
-}
-
-bool Triple::isArch16Bit() const {
-  return getArchPointerBitWidth(getArch()) == 16;
-}
-
-Triple Triple::get32BitArchVariant() const {
-  Triple T(*this);
-  switch (getArch()) {
-  case Triple::UnknownArch:
-  case Triple::amdgcn:
-  case Triple::avr:
-  case Triple::bpfeb:
-  case Triple::bpfel:
-  case Triple::msp430:
-  case Triple::systemz:
-  case Triple::ve:
-    T.setArch(UnknownArch);
-    break;
-
-  case Triple::aarch64_32:
-  case Triple::amdil:
-  case Triple::arc:
-  case Triple::arm:
-  case Triple::armeb:
-  case Triple::csky:
-  case Triple::hexagon:
-  case Triple::hsail:
-  case Triple::kalimba:
-  case Triple::lanai:
-  case Triple::le32:
-  case Triple::m68k:
-  case Triple::mips:
-  case Triple::mipsel:
-  case Triple::nvptx:
-  case Triple::ppc:
-  case Triple::ppcle:
-  case Triple::r600:
-  case Triple::renderscript32:
-  case Triple::riscv32:
-  case Triple::shave:
-  case Triple::sparc:
-  case Triple::sparcel:
-  case Triple::spir:
-  case Triple::spirv32:
-  case Triple::tce:
-  case Triple::tcele:
-  case Triple::thumb:
-  case Triple::thumbeb:
-  case Triple::wasm32:
-  case Triple::x86:
-  case Triple::xcore:
-    // Already 32-bit.
-    break;
-
-  case Triple::aarch64:        T.setArch(Triple::arm);     break;
-  case Triple::aarch64_be:     T.setArch(Triple::armeb);   break;
-  case Triple::amdil64:        T.setArch(Triple::amdil);   break;
-  case Triple::hsail64:        T.setArch(Triple::hsail);   break;
-  case Triple::le64:           T.setArch(Triple::le32);    break;
-  case Triple::mips64:
-    T.setArch(Triple::mips, getSubArch());
-    break;
-  case Triple::mips64el:
-    T.setArch(Triple::mipsel, getSubArch());
-    break;
-  case Triple::nvptx64:        T.setArch(Triple::nvptx);   break;
-  case Triple::ppc64:          T.setArch(Triple::ppc);     break;
-  case Triple::ppc64le:        T.setArch(Triple::ppcle);   break;
-  case Triple::renderscript64: T.setArch(Triple::renderscript32); break;
-  case Triple::riscv64:        T.setArch(Triple::riscv32); break;
-  case Triple::sparcv9:        T.setArch(Triple::sparc);   break;
-  case Triple::spir64:         T.setArch(Triple::spir);    break;
-  case Triple::spirv64:        T.setArch(Triple::spirv32); break;
-  case Triple::wasm64:         T.setArch(Triple::wasm32);  break;
-  case Triple::x86_64:         T.setArch(Triple::x86);     break;
-  }
-  return T;
-}
-
-Triple Triple::get64BitArchVariant() const {
-  Triple T(*this);
-  switch (getArch()) {
-  case Triple::UnknownArch:
-  case Triple::arc:
-  case Triple::avr:
-  case Triple::csky:
-  case Triple::hexagon:
-  case Triple::kalimba:
-  case Triple::lanai:
-  case Triple::m68k:
-  case Triple::msp430:
-  case Triple::r600:
-  case Triple::shave:
-  case Triple::sparcel:
-  case Triple::tce:
-  case Triple::tcele:
-  case Triple::xcore:
-    T.setArch(UnknownArch);
-    break;
-
-  case Triple::aarch64:
-  case Triple::aarch64_be:
-  case Triple::amdgcn:
-  case Triple::amdil64:
-  case Triple::bpfeb:
-  case Triple::bpfel:
-  case Triple::hsail64:
-  case Triple::le64:
-  case Triple::mips64:
-  case Triple::mips64el:
-  case Triple::nvptx64:
-  case Triple::ppc64:
-  case Triple::ppc64le:
-  case Triple::renderscript64:
-  case Triple::riscv64:
-  case Triple::sparcv9:
-  case Triple::spir64:
-  case Triple::spirv64:
-  case Triple::systemz:
-  case Triple::ve:
-  case Triple::wasm64:
-  case Triple::x86_64:
-    // Already 64-bit.
-    break;
-
-  case Triple::aarch64_32:      T.setArch(Triple::aarch64);    break;
-  case Triple::amdil:           T.setArch(Triple::amdil64);    break;
-  case Triple::arm:             T.setArch(Triple::aarch64);    break;
-  case Triple::armeb:           T.setArch(Triple::aarch64_be); break;
-  case Triple::hsail:           T.setArch(Triple::hsail64);    break;
-  case Triple::le32:            T.setArch(Triple::le64);       break;
-  case Triple::mips:
-    T.setArch(Triple::mips64, getSubArch());
-    break;
-  case Triple::mipsel:
-    T.setArch(Triple::mips64el, getSubArch());
-    break;
-  case Triple::nvptx:           T.setArch(Triple::nvptx64);    break;
-  case Triple::ppc:             T.setArch(Triple::ppc64);      break;
-  case Triple::ppcle:           T.setArch(Triple::ppc64le);    break;
-  case Triple::renderscript32:  T.setArch(Triple::renderscript64);     break;
-  case Triple::riscv32:         T.setArch(Triple::riscv64);    break;
-  case Triple::sparc:           T.setArch(Triple::sparcv9);    break;
-  case Triple::spir:            T.setArch(Triple::spir64);     break;
-  case Triple::spirv32:         T.setArch(Triple::spirv64);    break;
-  case Triple::thumb:           T.setArch(Triple::aarch64);    break;
-  case Triple::thumbeb:         T.setArch(Triple::aarch64_be); break;
-  case Triple::wasm32:          T.setArch(Triple::wasm64);     break;
-  case Triple::x86:             T.setArch(Triple::x86_64);     break;
-  }
-  return T;
-}
-
-Triple Triple::getBigEndianArchVariant() const {
-  Triple T(*this);
-  // Already big endian.
-  if (!isLittleEndian())
-    return T;
-  switch (getArch()) {
-  case Triple::UnknownArch:
-  case Triple::amdgcn:
-  case Triple::amdil64:
-  case Triple::amdil:
-  case Triple::avr:
-  case Triple::hexagon:
-  case Triple::hsail64:
-  case Triple::hsail:
-  case Triple::kalimba:
-  case Triple::le32:
-  case Triple::le64:
-  case Triple::msp430:
-  case Triple::nvptx64:
-  case Triple::nvptx:
-  case Triple::r600:
-  case Triple::renderscript32:
-  case Triple::renderscript64:
-  case Triple::riscv32:
-  case Triple::riscv64:
-  case Triple::shave:
-  case Triple::spir64:
-  case Triple::spir:
-  case Triple::spirv32:
-  case Triple::spirv64:
-  case Triple::wasm32:
-  case Triple::wasm64:
-  case Triple::x86:
-  case Triple::x86_64:
-  case Triple::xcore:
-  case Triple::ve:
-  case Triple::csky:
-
-  // ARM is intentionally unsupported here, changing the architecture would
-  // drop any arch suffixes.
-  case Triple::arm:
-  case Triple::thumb:
-    T.setArch(UnknownArch);
-    break;
-
-  case Triple::aarch64: T.setArch(Triple::aarch64_be); break;
-  case Triple::bpfel:   T.setArch(Triple::bpfeb);      break;
-  case Triple::mips64el:
-    T.setArch(Triple::mips64, getSubArch());
-    break;
-  case Triple::mipsel:
-    T.setArch(Triple::mips, getSubArch());
-    break;
-  case Triple::ppcle:   T.setArch(Triple::ppc);        break;
-  case Triple::ppc64le: T.setArch(Triple::ppc64);      break;
-  case Triple::sparcel: T.setArch(Triple::sparc);      break;
-  case Triple::tcele:   T.setArch(Triple::tce);        break;
-  default:
-    llvm_unreachable("getBigEndianArchVariant: unknown triple.");
-  }
-  return T;
-}
-
-Triple Triple::getLittleEndianArchVariant() const {
-  Triple T(*this);
-  if (isLittleEndian())
-    return T;
-
-  switch (getArch()) {
-  case Triple::UnknownArch:
-  case Triple::lanai:
-  case Triple::sparcv9:
-  case Triple::systemz:
-  case Triple::m68k:
-
-  // ARM is intentionally unsupported here, changing the architecture would
-  // drop any arch suffixes.
-  case Triple::armeb:
-  case Triple::thumbeb:
-    T.setArch(UnknownArch);
-    break;
-
-  case Triple::aarch64_be: T.setArch(Triple::aarch64);  break;
-  case Triple::bpfeb:      T.setArch(Triple::bpfel);    break;
-  case Triple::mips64:
-    T.setArch(Triple::mips64el, getSubArch());
-    break;
-  case Triple::mips:
-    T.setArch(Triple::mipsel, getSubArch());
-    break;
-  case Triple::ppc:        T.setArch(Triple::ppcle);    break;
-  case Triple::ppc64:      T.setArch(Triple::ppc64le);  break;
-  case Triple::sparc:      T.setArch(Triple::sparcel);  break;
-  case Triple::tce:        T.setArch(Triple::tcele);    break;
-  default:
-    llvm_unreachable("getLittleEndianArchVariant: unknown triple.");
-  }
-  return T;
-}
-
-bool Triple::isLittleEndian() const {
-  switch (getArch()) {
-  case Triple::aarch64:
-  case Triple::aarch64_32:
-  case Triple::amdgcn:
-  case Triple::amdil64:
-  case Triple::amdil:
-  case Triple::arm:
-  case Triple::avr:
-  case Triple::bpfel:
-  case Triple::csky:
-  case Triple::hexagon:
-  case Triple::hsail64:
-  case Triple::hsail:
-  case Triple::kalimba:
-  case Triple::le32:
-  case Triple::le64:
-  case Triple::mips64el:
-  case Triple::mipsel:
-  case Triple::msp430:
-  case Triple::nvptx64:
-  case Triple::nvptx:
-  case Triple::ppcle:
-  case Triple::ppc64le:
-  case Triple::r600:
-  case Triple::renderscript32:
-  case Triple::renderscript64:
-  case Triple::riscv32:
-  case Triple::riscv64:
-  case Triple::shave:
-  case Triple::sparcel:
-  case Triple::spir64:
-  case Triple::spir:
-  case Triple::spirv32:
-  case Triple::spirv64:
-  case Triple::tcele:
-  case Triple::thumb:
-  case Triple::ve:
-  case Triple::wasm32:
-  case Triple::wasm64:
-  case Triple::x86:
-  case Triple::x86_64:
-  case Triple::xcore:
-    return true;
-  default:
-    return false;
-  }
-}
-
-bool Triple::isCompatibleWith(const Triple &Other) const {
-  // ARM and Thumb triples are compatible, if subarch, vendor and OS match.
-  if ((getArch() == Triple::thumb && Other.getArch() == Triple::arm) ||
-      (getArch() == Triple::arm && Other.getArch() == Triple::thumb) ||
-      (getArch() == Triple::thumbeb && Other.getArch() == Triple::armeb) ||
-      (getArch() == Triple::armeb && Other.getArch() == Triple::thumbeb)) {
-    if (getVendor() == Triple::Apple)
-      return getSubArch() == Other.getSubArch() &&
-             getVendor() == Other.getVendor() && getOS() == Other.getOS();
-    else
-      return getSubArch() == Other.getSubArch() &&
-             getVendor() == Other.getVendor() && getOS() == Other.getOS() &&
-             getEnvironment() == Other.getEnvironment() &&
-             getObjectFormat() == Other.getObjectFormat();
-  }
-
-  // If vendor is apple, ignore the version number.
-  if (getVendor() == Triple::Apple)
-    return getArch() == Other.getArch() && getSubArch() == Other.getSubArch() &&
-           getVendor() == Other.getVendor() && getOS() == Other.getOS();
-
-  return *this == Other;
-}
-
-std::string Triple::merge(const Triple &Other) const {
-  // If vendor is apple, pick the triple with the larger version number.
-  if (getVendor() == Triple::Apple)
-    if (Other.isOSVersionLT(*this))
-      return str();
-
-  return Other.str();
-}
-
-bool Triple::isMacOSXVersionLT(unsigned Major, unsigned Minor,
-                               unsigned Micro) const {
-  assert(isMacOSX() && "Not an OS X triple!");
-
-  // If this is OS X, expect a sane version number.
-  if (getOS() == Triple::MacOSX)
-    return isOSVersionLT(Major, Minor, Micro);
-
-  // Otherwise, compare to the "Darwin" number.
-  if (Major == 10) {
-    return isOSVersionLT(Minor + 4, Micro, 0);
-  } else {
-    assert(Major >= 11 && "Unexpected major version");
-    return isOSVersionLT(Major - 11 + 20, Minor, Micro);
-  }
-}
-
-VersionTuple Triple::getMinimumSupportedOSVersion() const {
-  if (getVendor() != Triple::Apple || getArch() != Triple::aarch64)
-    return VersionTuple();
-  switch (getOS()) {
-  case Triple::MacOSX:
-    // ARM64 slice is supported starting from macOS 11.0+.
-    return VersionTuple(11, 0, 0);
-  case Triple::IOS:
-    // ARM64 slice is supported starting from Mac Catalyst 14 (macOS 11).
-    // ARM64 simulators are supported for iOS 14+.
-    if (isMacCatalystEnvironment() || isSimulatorEnvironment())
-      return VersionTuple(14, 0, 0);
-    // ARM64e slice is supported starting from iOS 14.
-    if (isArm64e())
-      return VersionTuple(14, 0, 0);
-    break;
-  case Triple::TvOS:
-    // ARM64 simulators are supported for tvOS 14+.
-    if (isSimulatorEnvironment())
-      return VersionTuple(14, 0, 0);
-    break;
-  case Triple::WatchOS:
-    // ARM64 simulators are supported for watchOS 7+.
-    if (isSimulatorEnvironment())
-      return VersionTuple(7, 0, 0);
-    break;
-  default:
-    break;
-  }
-  return VersionTuple();
-}
-
-StringRef Triple::getARMCPUForArch(StringRef MArch) const {
-  if (MArch.empty())
-    MArch = getArchName();
-  MArch = ARM::getCanonicalArchName(MArch);
-
-  // Some defaults are forced.
-  switch (getOS()) {
-  case llvm::Triple::FreeBSD:
-  case llvm::Triple::NetBSD:
-  case llvm::Triple::OpenBSD:
-    if (!MArch.empty() && MArch == "v6")
-      return "arm1176jzf-s";
-    if (!MArch.empty() && MArch == "v7")
-      return "cortex-a8";
-    break;
-  case llvm::Triple::Win32:
-    // FIXME: this is invalid for WindowsCE
-    if (ARM::parseArchVersion(MArch) <= 7)
-      return "cortex-a9";
-    break;
-  case llvm::Triple::IOS:
-  case llvm::Triple::MacOSX:
-  case llvm::Triple::TvOS:
-  case llvm::Triple::WatchOS:
-    if (MArch == "v7k")
-      return "cortex-a7";
-    break;
-  default:
-    break;
-  }
-
-  if (MArch.empty())
-    return StringRef();
-
-  StringRef CPU = ARM::getDefaultCPU(MArch);
-  if (!CPU.empty() && !CPU.equals("invalid"))
-    return CPU;
-
-  // If no specific architecture version is requested, return the minimum CPU
-  // required by the OS and environment.
-  switch (getOS()) {
-  case llvm::Triple::NetBSD:
-    switch (getEnvironment()) {
-    case llvm::Triple::EABI:
-    case llvm::Triple::EABIHF:
-    case llvm::Triple::GNUEABI:
-    case llvm::Triple::GNUEABIHF:
-      return "arm926ej-s";
-    default:
-      return "strongarm";
-    }
-  case llvm::Triple::NaCl:
-  case llvm::Triple::OpenBSD:
-    return "cortex-a8";
-  default:
-    switch (getEnvironment()) {
-    case llvm::Triple::EABIHF:
-    case llvm::Triple::GNUEABIHF:
-    case llvm::Triple::MuslEABIHF:
-      return "arm1176jzf-s";
-    default:
-      return "arm7tdmi";
-    }
-  }
-
-  llvm_unreachable("invalid arch name");
-}
-
-VersionTuple Triple::getCanonicalVersionForOS(OSType OSKind,
-                                              const VersionTuple &Version) {
-  switch (OSKind) {
-  case MacOSX:
-    // macOS 10.16 is canonicalized to macOS 11.
-    if (Version == VersionTuple(10, 16))
-      return VersionTuple(11, 0);
-    LLVM_FALLTHROUGH;
-  default:
-    return Version;
-  }
-}
diff --git a/llvm/lib/Support/Triple.cpp b/llvm/lib/Support/Triple.cpp
new file mode 120000
index 000000000000..9cbe6e127bd4
--- /dev/null
+++ b/llvm/lib/Support/Triple.cpp
@@ -0,0 +1 @@
+/home/ormastes/dev/pri/toy-riscv-backend/llvm/lib/Support/Triple.cpp
\ No newline at end of file
